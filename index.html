<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GLB Walkthrough Viewer</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' rx='6' fill='%230a0a0b'/><path d='M6 22 L11 10 L16 18 L19 13 L26 22Z' fill='%23c8ff00' opacity='0.9'/><circle cx='22' cy='10' r='3' fill='%23c8ff00' opacity='0.6'/></svg>">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Syne:wght@400;700;800&family=DM+Mono:wght@400;500&display=swap');
  :root {
    --bg:#0a0a0b;--surface:#111114;--border:#1e1e24;
    --accent:#c8ff00;--text:#e8e8e0;--muted:#555560;--panel-w:280px;
  }
  *{margin:0;padding:0;box-sizing:border-box;}
  body{background:var(--bg);color:var(--text);font-family:'Syne',sans-serif;overflow:hidden;height:100vh;width:100vw;}
  #canvas-container{position:fixed;inset:0;z-index:0;}
  canvas{display:block;touch-action:none;}

  #ui{position:fixed;inset:0;z-index:10;pointer-events:none;}

  /* Top bar */
  #topbar{position:absolute;top:0;left:0;right:0;height:52px;background:linear-gradient(180deg,rgba(10,10,11,0.95) 0%,transparent 100%);display:flex;align-items:center;padding:0 20px;gap:16px;pointer-events:all;}
  #logo{font-size:13px;font-weight:800;letter-spacing:0.15em;text-transform:uppercase;color:var(--accent);}
  #model-name{font-family:'DM Mono',monospace;font-size:12px;color:var(--muted);flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
  .btn{background:var(--accent);color:#0a0a0b;border:none;font-family:'Syne',sans-serif;font-size:11px;font-weight:700;letter-spacing:0.1em;text-transform:uppercase;padding:7px 14px;cursor:pointer;transition:opacity 0.15s;}
  .btn:hover{opacity:0.85;}
  .btn.secondary{background:transparent;color:var(--text);border:1px solid var(--border);}
  .btn.secondary:hover{border-color:var(--accent);color:var(--accent);}

  /* Panel toggle */
  #panel-toggle{position:absolute;top:52px;left:0;background:var(--surface);border:1px solid var(--border);border-left:none;padding:10px 8px;cursor:pointer;pointer-events:all;z-index:11;transition:left 0.3s cubic-bezier(0.16,1,0.3,1);font-size:14px;line-height:1;color:var(--text);font-family:monospace;}
  #panel-toggle.open{left:var(--panel-w);}

  /* Left panel */
  #panel-left{position:absolute;top:52px;left:0;bottom:0;width:var(--panel-w);background:rgba(10,10,11,0.9);backdrop-filter:blur(12px);border-right:1px solid var(--border);display:flex;flex-direction:column;transform:translateX(-100%);transition:transform 0.3s cubic-bezier(0.16,1,0.3,1);pointer-events:all;overflow-y:auto;}
  #panel-left.open{transform:translateX(0);}
  #panel-left::-webkit-scrollbar{width:3px;}
  #panel-left::-webkit-scrollbar-thumb{background:var(--border);}

  .panel-section{border-bottom:1px solid var(--border);}
  .panel-header{padding:12px 20px;font-size:10px;font-weight:700;letter-spacing:0.2em;text-transform:uppercase;color:var(--muted);cursor:pointer;display:flex;justify-content:space-between;align-items:center;transition:color 0.2s;}
  .panel-header:hover{color:var(--text);}
  .panel-header .arrow{font-size:10px;transition:transform 0.25s;}
  .panel-header.open .arrow{transform:rotate(180deg);}
  .panel-body{padding:8px 0;display:none;}
  .panel-body.open{display:block;}

  /* Camera list */
  .cam-item{display:flex;align-items:center;gap:10px;padding:10px 20px;cursor:pointer;transition:background 0.1s;border-left:2px solid transparent;}
  .cam-item:hover{background:rgba(200,255,0,0.05);}
  .cam-item.active{border-left-color:var(--accent);background:rgba(200,255,0,0.08);}
  .cam-icon{width:28px;height:28px;border:1px solid var(--border);display:flex;align-items:center;justify-content:center;font-size:12px;flex-shrink:0;}
  .cam-item.active .cam-icon{border-color:var(--accent);}
  .cam-label{font-family:'DM Mono',monospace;font-size:11px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}

  /* HDR section */
  .hdr-presets{padding:8px 12px;}
  .hdr-preset-btn{width:100%;text-align:left;padding:8px 12px;background:rgba(255,255,255,0.03);border:1px solid var(--border);color:var(--text);font-family:'DM Mono',monospace;font-size:11px;cursor:pointer;margin-bottom:4px;transition:all 0.2s;display:flex;align-items:center;gap:8px;}
  .hdr-preset-btn:hover{border-color:var(--accent);color:var(--accent);}
  .hdr-preset-btn.active{border-color:var(--accent);background:rgba(200,255,0,0.08);color:var(--accent);}
  .hdr-dot{width:24px;height:24px;border-radius:50%;flex-shrink:0;}

  .hdr-toggle-row{display:flex;align-items:center;justify-content:space-between;padding:8px 20px 12px;}
  .hdr-toggle-label{font-family:'DM Mono',monospace;font-size:10px;color:var(--muted);}
  .mini-toggle{position:relative;width:32px;height:18px;}
  .mini-toggle input{opacity:0;width:0;height:0;}
  .mini-slider{position:absolute;inset:0;background:rgba(255,255,255,0.1);border-radius:18px;cursor:pointer;transition:background 0.2s;}
  .mini-slider::before{content:'';position:absolute;width:12px;height:12px;left:3px;top:3px;background:#fff;border-radius:50%;transition:transform 0.2s;}
  .mini-toggle input:checked+.mini-slider{background:var(--accent);}
  .mini-toggle input:checked+.mini-slider::before{transform:translateX(14px);}

  /* Controls hint */
  #controls-hint{padding:14px 20px;font-family:'DM Mono',monospace;font-size:10px;color:var(--muted);line-height:1.9;}
  .hint-key{display:inline-block;background:var(--border);padding:1px 5px;font-size:9px;color:var(--text);}

  /* Slider rows */
  .slider-row{display:flex;align-items:center;gap:6px;padding:5px 16px;font-family:'DM Mono',monospace;font-size:10px;color:var(--muted);}
  .slider-row label{width:62px;flex-shrink:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
  .slider-row input[type="range"]{flex:1;height:3px;-webkit-appearance:none;appearance:none;background:var(--border);outline:none;border-radius:2px;cursor:pointer;}
  .slider-row input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;border-radius:50%;background:var(--accent);cursor:pointer;}
  .slider-row input[type="range"]::-moz-range-thumb{width:12px;height:12px;border-radius:50%;background:var(--accent);border:none;cursor:pointer;}
  .slider-val{width:34px;text-align:right;font-size:10px;color:var(--text);flex-shrink:0;}
  .slider-group-label{padding:8px 16px 2px;font-family:'DM Mono',monospace;font-size:9px;font-weight:700;letter-spacing:0.1em;color:var(--accent);opacity:0.7;}
  .slider-row input[type="color"]{flex:1;height:22px;border:1px solid var(--border);background:var(--surface);cursor:pointer;padding:1px 2px;max-width:80px;}

  /* Center overlay */
  #overlay-msg{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;pointer-events:all;}
  .msg-box{background:rgba(10,10,11,0.92);border:1px solid var(--border);padding:40px 48px;text-align:center;max-width:480px;width:90%;backdrop-filter:blur(20px);}
  .msg-title{font-size:28px;font-weight:800;letter-spacing:-0.02em;margin-bottom:8px;}
  .msg-title span{color:var(--accent);}
  .msg-sub{font-family:'DM Mono',monospace;font-size:12px;color:var(--muted);margin-bottom:28px;line-height:1.6;}
  .url-input-wrap{display:flex;flex-direction:column;gap:10px;margin-bottom:16px;}
  .url-input{background:var(--surface);border:1px solid var(--border);color:var(--text);font-family:'DM Mono',monospace;font-size:12px;padding:10px 14px;width:100%;outline:none;transition:border-color 0.2s;}
  .url-input:focus{border-color:var(--accent);}
  .url-input::placeholder{color:var(--muted);}
  .input-hint{font-family:'DM Mono',monospace;font-size:10px;color:var(--muted);text-align:left;padding:0 2px;}
  #loading-bar-wrap{position:absolute;bottom:0;left:0;right:0;height:2px;background:var(--border);display:none;}
  #loading-bar{height:100%;background:var(--accent);width:0%;transition:width 0.2s;}

  /* Bottom right */
  #bottom-right{position:absolute;bottom:20px;right:20px;display:flex;flex-direction:column;align-items:flex-end;gap:10px;pointer-events:all;}
  #lock-msg{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);background:rgba(10,10,11,0.85);border:1px solid var(--border);padding:8px 16px;font-family:'DM Mono',monospace;font-size:11px;color:var(--muted);pointer-events:none;white-space:nowrap;display:none;}

  body.walking{cursor:none;}
  #crosshair{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);pointer-events:none;display:none;}
  #crosshair::before,#crosshair::after{content:'';position:absolute;background:rgba(200,255,0,0.8);}
  #crosshair::before{width:12px;height:1px;top:0;left:-6px;}
  #crosshair::after{width:1px;height:12px;top:-6px;left:0;}
  #fps-badge{position:absolute;top:60px;right:14px;font-family:'DM Mono',monospace;font-size:10px;color:var(--muted);pointer-events:none;}

  @media(max-width:600px){:root{--panel-w:240px;}.msg-box{padding:28px 24px;}.msg-title{font-size:22px;}}
</style>
</head>
<body>
<div id="canvas-container"></div>
<div id="ui">
  <div id="topbar">
    <div id="logo">Walk<span style="color:var(--text)">View</span></div>
    <div id="model-name">GLBãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„</div>
    <button class="btn secondary" id="btn-reload" style="display:none" onclick="showLoadDialog()">å¤‰æ›´</button>
  </div>

  <button id="panel-toggle" onclick="togglePanel()">â˜°</button>

  <div id="panel-left">
    <!-- Camera section -->
    <div class="panel-section">
      <div class="panel-header open" onclick="toggleSection(this)">
        <span>ğŸ“· ã‚«ãƒ¡ãƒ©</span><span class="arrow">â–¾</span>
      </div>
      <div class="panel-body open" id="camera-list">
        <div style="padding:16px 20px;font-family:'DM Mono',monospace;font-size:11px;color:var(--muted)">GLBã‚’èª­ã¿è¾¼ã‚€ã¨è¡¨ç¤º</div>
      </div>
    </div>

    <!-- HDR section -->
    <div class="panel-section">
      <div class="panel-header" onclick="toggleSection(this)">
        <span>ğŸŒ… HDR ç’°å¢ƒå…‰</span><span class="arrow">â–¾</span>
      </div>
      <div class="panel-body" id="hdr-body">
        <div class="hdr-toggle-row">
          <span class="hdr-toggle-label">èƒŒæ™¯ã«è¡¨ç¤º</span>
          <label class="mini-toggle">
            <input type="checkbox" id="hdr-bg-toggle" checked onchange="toggleHDRBackground()">
            <div class="mini-slider"></div>
          </label>
        </div>
        <div class="hdr-presets" id="hdr-presets"></div>
      </div>
    </div>

    <!-- Lighting adjust -->
    <div class="panel-section">
      <div class="panel-header" onclick="toggleSection(this)">
        <span>ğŸ’¡ ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°èª¿æ•´</span><span class="arrow">â–¾</span>
      </div>
      <div class="panel-body" id="light-body">

        <div class="slider-group-label">â–¸ ãƒˆãƒ¼ãƒ³ãƒãƒƒãƒ”ãƒ³ã‚°</div>
        <div class="slider-row">
          <label>éœ²å‡º</label>
          <input type="range" min="0.1" max="3" step="0.05" value="1.0" id="sl-exposure" oninput="updateLighting()">
          <span class="slider-val" id="sv-exposure">1.00</span>
        </div>

        <div class="slider-group-label">â–¸ ç›´å°„å…‰ (Directional)</div>
        <div class="slider-row">
          <label>å¼·åº¦</label>
          <input type="range" min="0" max="8" step="0.1" value="3.0" id="sl-dir" oninput="updateLighting()">
          <span class="slider-val" id="sv-dir">3.0</span>
        </div>
        <div class="slider-row">
          <label>è‰²</label>
          <input type="color" value="#ffffff" id="sl-dir-color" oninput="updateLighting()">
          <span class="slider-val" id="sv-dir-color">#fff</span>
        </div>
        <div class="slider-row">
          <label>æ°´å¹³è§’</label>
          <input type="range" min="0" max="360" step="1" value="45" id="sl-dir-azimuth" oninput="updateLighting()">
          <span class="slider-val" id="sv-dir-azimuth">45Â°</span>
        </div>
        <div class="slider-row">
          <label>ä»°è§’</label>
          <input type="range" min="5" max="90" step="1" value="60" id="sl-dir-elevation" oninput="updateLighting()">
          <span class="slider-val" id="sv-dir-elevation">60Â°</span>
        </div>
        <div class="hdr-toggle-row" style="padding:4px 16px 8px">
          <span class="hdr-toggle-label">å½±</span>
          <label class="mini-toggle">
            <input type="checkbox" id="sl-dir-shadow" checked oninput="updateLighting()">
            <div class="mini-slider"></div>
          </label>
        </div>

        <div class="slider-group-label">â–¸ ç’°å¢ƒå…‰ (Ambient)</div>
        <div class="slider-row">
          <label>å¼·åº¦</label>
          <input type="range" min="0" max="2" step="0.01" value="0.8" id="sl-amb" oninput="updateLighting()">
          <span class="slider-val" id="sv-amb">0.80</span>
        </div>
        <div class="slider-row">
          <label>è‰²</label>
          <input type="color" value="#ffffff" id="sl-amb-color" oninput="updateLighting()">
          <span class="slider-val" id="sv-amb-color">#fff</span>
        </div>

        <div class="slider-group-label">â–¸ åŠçƒå…‰ (Hemisphere)</div>
        <div class="slider-row">
          <label>å¼·åº¦</label>
          <input type="range" min="0" max="2" step="0.01" value="0" id="sl-hemi" oninput="updateLighting()">
          <span class="slider-val" id="sv-hemi">0.00</span>
        </div>
        <div class="slider-row">
          <label>å¤©ç©ºè‰²</label>
          <input type="color" value="#ffffff" id="sl-hemi-sky" oninput="updateLighting()">
          <span class="slider-val" id="sv-hemi-sky">#fff</span>
        </div>
        <div class="slider-row">
          <label>åœ°é¢è‰²</label>
          <input type="color" value="#ffffff" id="sl-hemi-gnd" oninput="updateLighting()">
          <span class="slider-val" id="sv-hemi-gnd">#ffffff</span>
        </div>

        <div class="slider-group-label">â–¸ ãƒãƒ†ãƒªã‚¢ãƒ« / ãƒã‚¹ãƒ—ãƒ­</div>
        <div class="slider-row">
          <label>åå°„å¼·åº¦</label>
          <input type="range" min="0" max="4" step="0.1" value="1.5" id="sl-envmap" oninput="updateLighting()">
          <span class="slider-val" id="sv-envmap">1.5</span>
        </div>
        <div class="slider-row">
          <label>æ”¾å°„å…‰ å¼·åº¦</label>
          <input type="range" min="0" max="10" step="0.1" value="1.0" id="sl-emissive-mul" oninput="updateLighting()">
          <span class="slider-val" id="sv-emissive-mul">1.0</span>
        </div>
        <div class="slider-row">
          <label>Bloom å¼·åº¦</label>
          <input type="range" min="0" max="0.5" step="0.01" value="0.06" id="sl-bloom-str" oninput="updateLighting()">
          <span class="slider-val" id="sv-bloom-str">0.06</span>
        </div>
        <div class="slider-row">
          <label>Bloom é–¾å€¤</label>
          <input type="range" min="0" max="1.5" step="0.01" value="0.9" id="sl-bloom-th" oninput="updateLighting()">
          <span class="slider-val" id="sv-bloom-th">0.90</span>
        </div>

        <div style="padding:4px 16px 12px">
          <button class="btn secondary" style="width:100%;padding:6px;font-size:10px" onclick="resetLighting()">ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
      </div>
    </div>

    <!-- Controls -->
    <div style="margin-top:auto;">
      <div id="controls-hint">
        <span class="hint-key">W A S D</span> ç§»å‹•<br>
        <span class="hint-key">Mouse</span> è¦–ç‚¹<br>
        <span class="hint-key">Space</span> ä¸Šæ˜‡ &nbsp;<span class="hint-key">Shift</span> ä¸‹é™<br>
        <span class="hint-key">Esc</span> è§£æ”¾<br>
        <br>
        <span style="color:var(--accent)">ğŸ“± ãƒ¢ãƒã‚¤ãƒ«</span><br>
        å·¦åŠåˆ†ãƒ‰ãƒ©ãƒƒã‚° â†’ ç§»å‹•<br>
        å³åŠåˆ†ãƒ‰ãƒ©ãƒƒã‚° â†’ è¦–ç‚¹
      </div>
    </div>
  </div>

  <div id="overlay-msg">
    <div class="msg-box">
      <div class="msg-title">Walk<span>View</span></div>
      <div class="msg-sub">GLBã‚¦ã‚©ãƒ¼ã‚¯ã‚¹ãƒ«ãƒ¼ãƒ“ãƒ¥ãƒ¼ã‚¢<br>URLã‚’å…¥åŠ›ã—ã¦èª­ã¿è¾¼ã¿</div>
      <div class="url-input-wrap">
        <input class="url-input" id="glb-url-input" type="text" placeholder="https://...supabase.co/.../model.glb" />
        <div class="input-hint">ğŸ’¡ ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ€ãƒ¼ã§ç”Ÿæˆã•ã‚ŒãŸURLã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„</div>
      </div>
      <button class="btn" onclick="loadFromInput()" style="width:100%;padding:12px">GLBã‚’èª­ã¿è¾¼ã‚€ â†’</button>
      <button class="btn secondary" id="btn-close-overlay" onclick="closeLoadDialog()" style="width:100%;padding:10px;margin-top:8px;display:none">âœ• é–‰ã˜ã‚‹</button>
    </div>
    <div id="loading-bar-wrap"><div id="loading-bar"></div></div>
  </div>

  <div id="crosshair"></div>

  <div id="lock-msg">ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ­©è¡Œãƒ¢ãƒ¼ãƒ‰é–‹å§‹ â€” Escã§è§£æ”¾</div>
  <div id="fps-badge"></div>
</div>

<script type="importmap">
{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"}}
</script>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

// ===== RENDERER =====
const container = document.getElementById('canvas-container');
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
container.appendChild(renderer.domElement);
const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

// ===== SCENE =====
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0a0b);

const walkCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 500);
walkCamera.position.set(0, 1.6, 0);
let activeCamera = walkCamera;
let glbCameras = [];
let activeCamIdx = -1;

// ===== POST-PROCESSING (Bloom) =====
const composer = new EffectComposer(renderer);
const renderPass = new RenderPass(scene, walkCamera);
composer.addPass(renderPass);
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  0.06, 0.4, 0.9
);
composer.addPass(bloomPass);
composer.addPass(new OutputPass());

// ===== LIGHTING =====
const ambient = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambient);

const dirLight = new THREE.DirectionalLight(0xffffff, 3.0);
dirLight.position.set(15, 30, 15);
dirLight.castShadow = true;
// é«˜å“è³ªå½±ã®è¨­å®š
dirLight.shadow.mapSize.width  = 2048;
dirLight.shadow.mapSize.height = 2048;
dirLight.shadow.camera.near    = 0.1;
dirLight.shadow.camera.far     = 300;
dirLight.shadow.camera.left    = -60;
dirLight.shadow.camera.right   =  60;
dirLight.shadow.camera.top     =  60;
dirLight.shadow.camera.bottom  = -60;
dirLight.shadow.bias           = -0.0005;
dirLight.shadow.normalBias     = 0.02;
scene.add(dirLight);

const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0);
scene.add(hemiLight);

// ===== HDR =====
const rgbeLoader = new RGBELoader();
const pmremGenerator = new THREE.PMREMGenerator(renderer);
pmremGenerator.compileEquirectangularShader();

// HDRãŒãªã„å ´åˆã§ã‚‚é»’ããªã‚‰ãªã„ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«ç’°å¢ƒãƒãƒƒãƒ—ï¼ˆCanvasç”Ÿæˆï¼‰
{
  const c = document.createElement('canvas');
  c.width = 128; c.height = 64;
  const ctx = c.getContext('2d');
  const g = ctx.createLinearGradient(0, 0, 0, 64);
  g.addColorStop(0, '#a0a8b8');
  g.addColorStop(0.4, '#8890a0');
  g.addColorStop(0.5, '#707888');
  g.addColorStop(1, '#404550');
  ctx.fillStyle = g; ctx.fillRect(0, 0, 128, 64);
  const tex = new THREE.CanvasTexture(c);
  tex.mapping = THREE.EquirectangularReflectionMapping;
  const neutralEnv = pmremGenerator.fromEquirectangular(tex).texture;
  tex.dispose();
  scene.environment = neutralEnv;
}

let currentEnvMap = null;
let currentBgMap = null;
let hdrBgEnabled = true;
let activeHdrIdx = -1;
let HDR_PRESETS = [];

async function buildHDRPanel() {
  const container = document.getElementById('hdr-presets');
  container.innerHTML = '<div style="padding:8px 12px;font-family:\'DM Mono\',monospace;font-size:10px;color:var(--muted)">èª­ã¿è¾¼ã¿ä¸­...</div>';

  try {
    // GitHub APIã§hdrãƒ•ã‚©ãƒ«ãƒ€ã®ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚’å–å¾—
    // URLã‹ã‚‰ã‚ªãƒ¼ãƒŠãƒ¼ã¨ãƒªãƒã‚¸ãƒˆãƒªåã‚’æŠ½å‡º
    const pathParts = window.location.pathname.split('/').filter(Boolean);
    const repoName = pathParts[0] || '';
    const owner = window.location.hostname.split('.')[0];
    const apiUrl = `https://api.github.com/repos/${owner}/${repoName}/contents/hdr`;

    const res = await fetch(apiUrl);
    if (!res.ok) throw new Error('API error');
    const files = await res.json();

    HDR_PRESETS = files
      .filter(f => f.name.toLowerCase().endsWith('.hdr'))
      .map(f => ({ file: f.name, label: f.name }));

    if (!HDR_PRESETS.length) throw new Error('HDRãƒ•ã‚¡ã‚¤ãƒ«ãªã—');

  } catch(e) {
    container.innerHTML = '<div style="padding:8px 12px;font-family:\'DM Mono\',monospace;font-size:10px;color:var(--muted)">hdr/ ãƒ•ã‚©ãƒ«ãƒ€ã«HDRãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ ã—ã¦ãã ã•ã„</div>';
    return;
  }

  container.innerHTML = '';
  HDR_PRESETS.forEach((p, i) => {
    const btn = document.createElement('button');
    btn.className = 'hdr-preset-btn';
    btn.id = 'hdr-btn-' + i;
    btn.textContent = p.file;
    btn.onclick = () => loadHDR(i);
    container.appendChild(btn);
  });

  // æœ€åˆã®HDRã‚’è‡ªå‹•ãƒ­ãƒ¼ãƒ‰ï¼ˆã‚¨ãƒ©ãƒ¼ã¯é™ã‹ã«ç„¡è¦–ï¼‰
  if (HDR_PRESETS.length > 0) {
    loadHDR(0).catch(() => {});
  }
}

function loadHDR(idx) {
  const preset = HDR_PRESETS[idx];
  if (!preset) return Promise.resolve();
  document.querySelectorAll('.hdr-preset-btn').forEach((b, i) => b.classList.toggle('active', i === idx));
  activeHdrIdx = idx;
  const url = './hdr/' + preset.file;
  return new Promise((resolve, reject) => {
    rgbeLoader.load(url, (texture) => {
      // ã‚«ãƒ©ãƒ¼ç‰ˆ â†’ èƒŒæ™¯ç”¨
      if (currentBgMap) currentBgMap.dispose();
      currentBgMap = pmremGenerator.fromEquirectangular(texture).texture;

      // ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«åŒ– â†’ åå°„ç”¨
      const data = texture.image.data;
      const channels = 4;
      for (let i = 0; i < data.length; i += channels) {
        const gray = data[i] * 0.2126 + data[i+1] * 0.7152 + data[i+2] * 0.0722;
        data[i] = gray;
        data[i+1] = gray;
        data[i+2] = gray;
      }
      texture.needsUpdate = true;

      if (currentEnvMap) currentEnvMap.dispose();
      currentEnvMap = pmremGenerator.fromEquirectangular(texture).texture;
      texture.dispose();

      scene.environment = currentEnvMap;
      if (hdrBgEnabled) {
        scene.background = currentBgMap;
        scene.backgroundIntensity = 1.0;
      }
      resolve();
    }, undefined, (err) => {
      console.warn('HDRèª­ã¿è¾¼ã¿å¤±æ•—:', url);
      reject(err);
    });
  });
}

window.toggleHDRBackground = function() {
  hdrBgEnabled = document.getElementById('hdr-bg-toggle').checked;
  if (hdrBgEnabled && currentBgMap) {
    scene.background = currentBgMap;
    scene.backgroundIntensity = 1.0;
    scene.fog = null;
  } else {
    scene.background = new THREE.Color(0x0a0a0b);
    scene.backgroundIntensity = 1;
    if (loadedModel) scene.fog = new THREE.Fog(0x0a0a0b, 30, 120);
  }
};

// ===== GLB LOADER =====
const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
const gltfLoader = new GLTFLoader();
gltfLoader.setDRACOLoader(dracoLoader);

let loadedModel = null;

window.loadFromInput = function() {
  const raw = document.getElementById('glb-url-input').value.trim();
  if (!raw) return;
  let url = raw;
  try { url = encodeURI(decodeURI(raw)); } catch(e) {}
  loadGLB(url, raw);
};

function loadGLB(url, displayUrl) {
  const overlay = document.getElementById('overlay-msg');
  const loadBar = document.getElementById('loading-bar-wrap');
  const loadBarInner = document.getElementById('loading-bar');
  loadBar.style.display = 'block';
  loadBarInner.style.width = '5%';

  const newUrl = new URL(window.location.href);
  newUrl.searchParams.set('glb', url);
  window.history.replaceState({}, '', newUrl.toString());

  gltfLoader.load(url, (gltf) => {
    if (loadedModel) scene.remove(loadedModel);
    loadedModel = gltf.scene;
    gltf.scene.traverse(obj => {
      if (obj.isMesh) {
        obj.castShadow = true;
        obj.receiveShadow = true;
        const mats = Array.isArray(obj.material) ? obj.material : [obj.material];

        // é€æ˜ç´ æï¼ˆopacity < 0.5ï¼‰ã¯å½±ã‚’è½ã¨ã•ãªã„ï¼ˆå…‰ã‚’100%è²«é€šï¼‰
        if (mats.some(m => m.transparent && m.opacity <= 0.9)) {
          obj.castShadow = false;
        }

        // "Tree"ã‚’å«ã‚€ãƒ¡ãƒƒã‚·ãƒ¥ã¯ä¸¡é¢æç”»
        if (obj.name && /Tree/i.test(obj.name)) {
          mats.forEach(mat => { mat.side = THREE.DoubleSide; });
        }

        // ãƒãƒ†ãƒªã‚¢ãƒ«ã®ç’°å¢ƒåå°„ã‚’å¼·åŒ–
        mats.forEach(mat => {
          if (mat.isMeshStandardMaterial || mat.isMeshPhysicalMaterial) {
            mat.envMapIntensity = 1.5;
            mat.needsUpdate = true;
          }
        });
      }
    });
    scene.add(gltf.scene);

    // Emissive â†’ PointLight è‡ªå‹•ç”Ÿæˆ
    // å‰å›ã®emissiveãƒ©ã‚¤ãƒˆã‚’ã‚¯ãƒªã‚¢
    if (window._emissiveLights) {
      window._emissiveLights.forEach(l => scene.remove(l));
    }
    window._emissiveLights = [];
    const emissiveThreshold = 100;
    const maxEmissiveLights = 32;
    const emissiveCandidates = [];

    gltf.scene.traverse(obj => {
      if (!obj.isMesh) return;
      const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
      for (const mat of mats) {
        const intensity = mat.emissiveIntensity || 0;
        if (intensity >= emissiveThreshold && mat.emissive) {
          const pos = new THREE.Vector3();
          obj.getWorldPosition(pos);
          // ãƒ¡ãƒƒã‚·ãƒ¥ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‹ã‚‰ã‚µã‚¤ã‚ºã‚’æ¨å®š
          const bb = new THREE.Box3().setFromObject(obj);
          const sz = bb.getSize(new THREE.Vector3());
          const radius = Math.max(sz.x, sz.y, sz.z) * 3;
          emissiveCandidates.push({
            pos, color: mat.emissive.clone(),
            intensity: Math.min(intensity * 0.02, 5),
            distance: Math.max(radius, 3),
            name: obj.name || ''
          });
          break;
        }
      }
    });

    // å¼·ã„é †ã«ã‚½ãƒ¼ãƒˆã—ã¦ä¸Šé™ã¾ã§é…ç½®
    emissiveCandidates.sort((a, b) => b.intensity - a.intensity);
    const toPlace = emissiveCandidates.slice(0, maxEmissiveLights);
    toPlace.forEach(c => {
      const pl = new THREE.PointLight(c.color, c.intensity, c.distance);
      pl.position.copy(c.pos);
      pl.castShadow = false;
      pl.userData.baseIntensity = c.intensity;
      scene.add(pl);
      window._emissiveLights.push(pl);
    });
    if (toPlace.length > 0) {
      console.log(`EmissiveLight: ${toPlace.length}å€‹é…ç½®ï¼ˆå€™è£œ${emissiveCandidates.length}å€‹ï¼‰`);
    }

    // Cameras
    glbCameras = [];
    gltf.scene.traverse(obj => { if (obj.isCamera) glbCameras.push(obj); });
    if (gltf.cameras) gltf.cameras.forEach(c => { if (!glbCameras.includes(c)) glbCameras.push(c); });
    glbCameras.forEach(cam => {
      if (cam.isPerspectiveCamera) { cam.aspect = window.innerWidth / window.innerHeight; cam.updateProjectionMatrix(); }
    });

    // Fit shadow camera to model
    const box = new THREE.Box3().setFromObject(gltf.scene);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);
    dirLight.shadow.camera.left   = -maxDim;
    dirLight.shadow.camera.right  =  maxDim;
    dirLight.shadow.camera.top    =  maxDim;
    dirLight.shadow.camera.bottom = -maxDim;
    dirLight.shadow.camera.far    = maxDim * 4;
    dirLight.shadow.camera.updateProjectionMatrix();
    dirLightCenter.copy(center);
    dirLightDist = maxDim * 2;
    updateLighting(); // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼å€¤ã§ä½ç½®ã‚’è¨­å®š

    // Walk camera position
    const eyeH = size.y * 0.35 + box.min.y;
    walkCamera.position.set(center.x + Math.max(size.x, size.z) * 0.4, eyeH, center.z + Math.max(size.x, size.z) * 0.4);
    walkCamera.lookAt(center);
    yaw = -Math.PI / 4; pitch = 0;

    buildCameraList();
    overlay.style.display = 'none';
    loadBar.style.display = 'none';
    document.getElementById('btn-reload').style.display = '';
    document.getElementById('lock-msg').style.display = isMobile ? 'none' : 'block';
    const parts = (displayUrl || url).split('/');
    document.getElementById('model-name').textContent = decodeURIComponent(parts[parts.length - 1] || 'model.glb');
    activeCamera = walkCamera;
    activeCamIdx = -1;
    // GLBã‚«ãƒ¡ãƒ©ãŒã‚ã‚Œã°æœ€åˆã®ã‚«ãƒ¡ãƒ©ä½ç½®ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ
    if (glbCameras.length > 0) {
      switchCamera(0);
    }
  },
  (progress) => {
    if (progress.total > 0) loadBarInner.style.width = (progress.loaded / progress.total * 100).toFixed(0) + '%';
  },
  (error) => {
    loadBar.style.display = 'none';
    alert('èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:\n' + error.message);
  });
}

function buildCameraList() {
  const list = document.getElementById('camera-list');
  list.innerHTML = '';
  const walkItem = document.createElement('div');
  walkItem.className = 'cam-item active'; walkItem.dataset.idx = '-1';
  walkItem.innerHTML = `<div class="cam-icon">ğŸš¶</div><div class="cam-label">ã‚¦ã‚©ãƒ¼ã‚¯ã‚¹ãƒ«ãƒ¼</div>`;
  walkItem.onclick = () => switchCamera(-1);
  list.appendChild(walkItem);
  if (!glbCameras.length) {
    const n = document.createElement('div');
    n.style = 'padding:8px 20px;font-family:"DM Mono",monospace;font-size:10px;color:var(--muted)';
    n.textContent = 'GLBå†…ã«ã‚«ãƒ¡ãƒ©ãªã—'; list.appendChild(n);
  } else {
    glbCameras.forEach((cam, i) => {
      const item = document.createElement('div');
      item.className = 'cam-item'; item.dataset.idx = i;
      item.innerHTML = `<div class="cam-icon">ğŸ“·</div><div class="cam-label">${cam.name || 'Camera ' + (i+1)}</div>`;
      item.onclick = () => switchCamera(i); list.appendChild(item);
    });
  }
}

window.switchCamera = function(idx) {
  activeCamIdx = -1; // å¸¸ã«ã‚¦ã‚©ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰
  activeCamera = walkCamera;

  let camName = '';
  if (idx >= 0 && glbCameras[idx]) {
    // GLBã‚«ãƒ¡ãƒ©ã®ä½ç½®ã¨å‘ãã‚’walkCameraã«ã‚³ãƒ”ãƒ¼
    const cam = glbCameras[idx];
    camName = cam.name || '';
    cam.updateMatrixWorld(true);
    walkCamera.position.setFromMatrixPosition(cam.matrixWorld);
    // å‘ãã‹ã‚‰yaw/pitchã‚’æŠ½å‡º
    const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(cam.getWorldQuaternion(new THREE.Quaternion()));
    yaw = Math.atan2(-dir.x, -dir.z);
    pitch = Math.asin(Math.max(-1, Math.min(1, dir.y)));
  }

  // å¤–è¦³ãƒ»å¤–éƒ¨ã‚«ãƒ¡ãƒ©ã¯åå°„ã‚’æŠ‘ãˆã‚‹
  const isExterior = /å¤–è¦³|å¤–éƒ¨/.test(camName);
  const envVal = isExterior ? 0.5 : LIGHT_DEFAULTS.envmap;
  document.getElementById('sl-envmap').value = envVal;
  if (loadedModel) {
    loadedModel.traverse(obj => {
      if (obj.isMesh) {
        const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
        mats.forEach(m => { if (m.isMeshStandardMaterial || m.isMeshPhysicalMaterial) m.envMapIntensity = envVal; });
      }
    });
  }
  document.getElementById('sv-envmap').textContent = envVal.toFixed(1);

  document.getElementById('lock-msg').style.display = isMobile ? 'none' : 'block';
  document.querySelectorAll('.cam-item').forEach(el => el.classList.toggle('active', parseInt(el.dataset.idx) === idx));
};

// ===== WALK CONTROLS =====
let isLocked = false, yaw = 0, pitch = 0;
const keys = {};
const moveSpeed = 0.1;

renderer.domElement.addEventListener('click', () => {
  if (!loadedModel || isMobile) return;
  renderer.domElement.requestPointerLock();
});
document.addEventListener('pointerlockchange', () => {
  isLocked = !!document.pointerLockElement;
  document.getElementById('crosshair').style.display = isLocked ? 'block' : 'none';
  document.getElementById('lock-msg').style.display = isLocked ? 'none' : (loadedModel ? 'block' : 'none');
  document.body.classList.toggle('walking', isLocked);
});
document.addEventListener('mousemove', e => {
  if (!isLocked) return;
  yaw -= e.movementX * 0.002;
  pitch = Math.max(-Math.PI/2.2, Math.min(Math.PI/2.2, pitch - e.movementY * 0.002));
});
document.addEventListener('keydown', e => { keys[e.code] = true; });
document.addEventListener('keyup', e => { keys[e.code] = false; });

// ===== TOUCH CONTROLS (ãƒ¢ãƒã‚¤ãƒ«) =====
let touchLookId = null, touchMoveId = null;
let touchLookStart = {x:0, y:0};
let touchMoveStart = {x:0, y:0};
let touchMoveVec = {x:0, z:0};

renderer.domElement.addEventListener('touchstart', e => {
  if (activeCamIdx !== -1 || !loadedModel) return;
  for (const touch of e.changedTouches) {
    if (touch.clientX > window.innerWidth * 0.4 && touchLookId === null) {
      // å³åŠåˆ† â†’ è¦–ç‚¹æ“ä½œ
      touchLookId = touch.identifier;
      touchLookStart = {x: touch.clientX, y: touch.clientY};
    } else if (touch.clientX <= window.innerWidth * 0.4 && touchMoveId === null) {
      // å·¦åŠåˆ† â†’ ç§»å‹•
      touchMoveId = touch.identifier;
      touchMoveStart = {x: touch.clientX, y: touch.clientY};
      touchMoveVec = {x:0, z:0};
    }
  }
}, {passive:true});

renderer.domElement.addEventListener('touchmove', e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === touchLookId) {
      const dx = touch.clientX - touchLookStart.x;
      const dy = touch.clientY - touchLookStart.y;
      yaw -= dx * 0.003;
      pitch = Math.max(-Math.PI/2.2, Math.min(Math.PI/2.2, pitch - dy * 0.003));
      touchLookStart = {x: touch.clientX, y: touch.clientY};
    }
    if (touch.identifier === touchMoveId) {
      const dx = touch.clientX - touchMoveStart.x;
      const dy = touch.clientY - touchMoveStart.y;
      const len = Math.sqrt(dx*dx + dy*dy);
      if (len > 5) {
        touchMoveVec = {x: dx / len, z: dy / len};
      } else {
        touchMoveVec = {x:0, z:0};
      }
    }
  }
}, {passive:true});

const touchEnd = e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === touchLookId) touchLookId = null;
    if (touch.identifier === touchMoveId) { touchMoveId = null; touchMoveVec = {x:0, z:0}; }
  }
};
renderer.domElement.addEventListener('touchend', touchEnd, {passive:true});
renderer.domElement.addEventListener('touchcancel', touchEnd, {passive:true});

const euler = new THREE.Euler(0, 0, 0, 'YXZ');
const moveDir = new THREE.Vector3();
function updateWalk() {
  if (activeCamIdx !== -1) return;
  euler.set(pitch, yaw, 0); walkCamera.quaternion.setFromEuler(euler);
  moveDir.set(0, 0, 0);
  if (keys['KeyW']||keys['ArrowUp'])    moveDir.z -= 1;
  if (keys['KeyS']||keys['ArrowDown'])  moveDir.z += 1;
  if (keys['KeyA']||keys['ArrowLeft'])  moveDir.x -= 1;
  if (keys['KeyD']||keys['ArrowRight']) moveDir.x += 1;
  if (keys['Space'])                     moveDir.y += 1;
  if (keys['ShiftLeft']||keys['ShiftRight']) moveDir.y -= 1;
  // ã‚¿ãƒƒãƒç§»å‹•ã‚’åŠ ç®—
  if (touchMoveVec.x !== 0 || touchMoveVec.z !== 0) {
    moveDir.x += touchMoveVec.x;
    moveDir.z += touchMoveVec.z;
  }
  if (moveDir.length() > 0) {
    moveDir.normalize().multiplyScalar(moveSpeed).applyQuaternion(new THREE.Quaternion().setFromEuler(new THREE.Euler(0, yaw, 0)));
    walkCamera.position.add(moveDir);
  }
}

// ===== PANEL / SECTION =====
let panelOpen = false;
window.togglePanel = function() {
  panelOpen = !panelOpen;
  document.getElementById('panel-left').classList.toggle('open', panelOpen);
  document.getElementById('panel-toggle').classList.toggle('open', panelOpen);
  document.getElementById('panel-toggle').textContent = panelOpen ? 'âœ•' : 'â˜°';
};
window.toggleSection = function(header) {
  header.classList.toggle('open');
  const body = header.nextElementSibling;
  body.classList.toggle('open');
};
window.showLoadDialog = function() {
  document.getElementById('overlay-msg').style.display = 'flex';
  document.getElementById('lock-msg').style.display = 'none';
  // ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿æ¸ˆã¿ãªã‚‰é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
  document.getElementById('btn-close-overlay').style.display = loadedModel ? '' : 'none';
};
window.closeLoadDialog = function() {
  document.getElementById('overlay-msg').style.display = 'none';
  if (loadedModel) {
    document.getElementById('lock-msg').style.display = isMobile ? 'none' : 'block';
  }
};

// ===== LIGHTING ADJUST =====
const LIGHT_DEFAULTS = {
  exposure:1.0, dir:3.0, dirColor:'#ffffff', dirAzimuth:45, dirElevation:60, dirShadow:true,
  amb:0.8, ambColor:'#ffffff',
  hemi:0, hemiSky:'#ffffff', hemiGnd:'#ffffff',
  envmap:1.5, emissiveMul:1.0, bloomStr:0.06, bloomTh:0.9
};
let dirLightDist = 50; // ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿æ™‚ã«æ›´æ–°
let dirLightCenter = new THREE.Vector3();

window.updateLighting = function() {
  const v = (id) => parseFloat(document.getElementById(id).value);
  const c = (id) => document.getElementById(id).value;

  const exposure = v('sl-exposure');
  const dir = v('sl-dir');
  const dirColor = c('sl-dir-color');
  const azimuth = v('sl-dir-azimuth');
  const elevation = v('sl-dir-elevation');
  const dirShadow = document.getElementById('sl-dir-shadow').checked;
  const amb = v('sl-amb');
  const ambColor = c('sl-amb-color');
  const hemi = v('sl-hemi');
  const hemiSky = c('sl-hemi-sky');
  const hemiGnd = c('sl-hemi-gnd');
  const env = v('sl-envmap');
  const emMul = v('sl-emissive-mul');
  const bStr = v('sl-bloom-str');
  const bTh = v('sl-bloom-th');

  renderer.toneMappingExposure = exposure;

  dirLight.intensity = dir;
  dirLight.color.set(dirColor);
  dirLight.castShadow = dirShadow;
  // æ–¹å‘ã‚’çƒé¢åº§æ¨™ã‹ã‚‰è¨ˆç®—
  const azRad = azimuth * Math.PI / 180;
  const elRad = elevation * Math.PI / 180;
  dirLight.position.set(
    dirLightCenter.x + dirLightDist * Math.cos(elRad) * Math.sin(azRad),
    dirLightCenter.y + dirLightDist * Math.sin(elRad),
    dirLightCenter.z + dirLightDist * Math.cos(elRad) * Math.cos(azRad)
  );
  dirLight.target.position.copy(dirLightCenter);
  dirLight.target.updateMatrixWorld();

  ambient.intensity = amb;
  ambient.color.set(ambColor);

  hemiLight.intensity = hemi;
  hemiLight.color.set(hemiSky);
  hemiLight.groundColor.set(hemiGnd);

  bloomPass.strength = bStr;
  bloomPass.threshold = bTh;

  // Emissiveãƒ©ã‚¤ãƒˆå¼·åº¦ã‚’ä¸€æ‹¬èª¿æ•´
  if (window._emissiveLights) {
    window._emissiveLights.forEach(l => { l.intensity = l.userData.baseIntensity * emMul; });
  }

  if (loadedModel) {
    loadedModel.traverse(obj => {
      if (obj.isMesh) {
        const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
        mats.forEach(m => { if (m.isMeshStandardMaterial || m.isMeshPhysicalMaterial) m.envMapIntensity = env; });
      }
    });
  }

  // å€¤è¡¨ç¤ºã‚’æ›´æ–°
  document.getElementById('sv-exposure').textContent = exposure.toFixed(2);
  document.getElementById('sv-dir').textContent = dir.toFixed(1);
  document.getElementById('sv-dir-color').textContent = dirColor.substring(0,7);
  document.getElementById('sv-dir-azimuth').textContent = azimuth + 'Â°';
  document.getElementById('sv-dir-elevation').textContent = elevation + 'Â°';
  document.getElementById('sv-amb').textContent = amb.toFixed(2);
  document.getElementById('sv-amb-color').textContent = ambColor.substring(0,7);
  document.getElementById('sv-hemi').textContent = hemi.toFixed(2);
  document.getElementById('sv-hemi-sky').textContent = hemiSky.substring(0,7);
  document.getElementById('sv-hemi-gnd').textContent = hemiGnd.substring(0,7);
  document.getElementById('sv-envmap').textContent = env.toFixed(1);
  document.getElementById('sv-emissive-mul').textContent = emMul.toFixed(1);
  document.getElementById('sv-bloom-str').textContent = bStr.toFixed(2);
  document.getElementById('sv-bloom-th').textContent = bTh.toFixed(2);
};

window.resetLighting = function() {
  const d = LIGHT_DEFAULTS;
  document.getElementById('sl-exposure').value = d.exposure;
  document.getElementById('sl-dir').value = d.dir;
  document.getElementById('sl-dir-color').value = d.dirColor;
  document.getElementById('sl-dir-azimuth').value = d.dirAzimuth;
  document.getElementById('sl-dir-elevation').value = d.dirElevation;
  document.getElementById('sl-dir-shadow').checked = d.dirShadow;
  document.getElementById('sl-amb').value = d.amb;
  document.getElementById('sl-amb-color').value = d.ambColor;
  document.getElementById('sl-hemi').value = d.hemi;
  document.getElementById('sl-hemi-sky').value = d.hemiSky;
  document.getElementById('sl-hemi-gnd').value = d.hemiGnd;
  document.getElementById('sl-envmap').value = d.envmap;
  document.getElementById('sl-emissive-mul').value = d.emissiveMul;
  document.getElementById('sl-bloom-str').value = d.bloomStr;
  document.getElementById('sl-bloom-th').value = d.bloomTh;
  updateLighting();
};

// ===== RESIZE =====
window.addEventListener('resize', () => {
  walkCamera.aspect = window.innerWidth / window.innerHeight;
  walkCamera.updateProjectionMatrix();
  glbCameras.forEach(cam => { if (cam.isPerspectiveCamera) { cam.aspect = window.innerWidth / window.innerHeight; cam.updateProjectionMatrix(); } });
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
  bloomPass.resolution.set(window.innerWidth, window.innerHeight);
});

// ===== RENDER LOOP =====
let lastTime = 0, frameCount = 0;
function animate(time) {
  requestAnimationFrame(animate);
  updateWalk();
  renderPass.camera = activeCamera;
  composer.render();
  frameCount++;
  if (time - lastTime > 1000) {
    document.getElementById('fps-badge').textContent = frameCount + ' fps';
    frameCount = 0; lastTime = time;
  }
}

// ===== INIT =====
buildHDRPanel(); // asyncã€ã‚¨ãƒ©ãƒ¼ã¯å†…éƒ¨ã§å‡¦ç†
animate(0);

// Auto-load from URL
const params = new URLSearchParams(window.location.search);
const autoGlb = params.get('glb');
if (autoGlb) {
  document.getElementById('glb-url-input').value = autoGlb;
  loadGLB(autoGlb, autoGlb);
}
</script>
</body>
</html>
