<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GLTF ã‚¦ã‚©ãƒ¼ã‚¯ã‚¹ãƒ«ãƒ¼ ãƒ“ãƒ¥ãƒ¼ã‚¢</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap');

  :root {
    --bg-panel: rgba(15, 15, 20, 0.92);
    --bg-panel-hover: rgba(25, 25, 35, 0.95);
    --accent: #4fc3f7;
    --accent-dim: rgba(79, 195, 247, 0.15);
    --accent-glow: rgba(79, 195, 247, 0.3);
    --text: #e8eaed;
    --text-dim: #9aa0a6;
    --border: rgba(255, 255, 255, 0.08);
    --danger: #ef5350;
    --success: #66bb6a;
    --radius: 8px;
    --font: 'Noto Sans JP', sans-serif;
    --mono: 'JetBrains Mono', monospace;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    overflow: hidden;
    background: #000;
    font-family: var(--font);
    color: var(--text);
    user-select: none;
    cursor: crosshair;
  }

  #canvas-container {
    width: 100vw;
    height: 100vh;
    position: fixed;
    top: 0; left: 0;
    background: #1a1a2e;
  }

  canvas { display: block; }

  /* Welcome Screen */
  #welcome-screen {
    position: fixed;
    inset: 0;
    z-index: 500;
    background: linear-gradient(135deg, #0a0a12 0%, #12121f 50%, #0d0d18 100%);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    gap: 32px;
    transition: opacity 0.5s ease;
  }

  #welcome-screen.hidden {
    opacity: 0;
    pointer-events: none;
  }

  #welcome-screen h1 {
    font-size: 28px;
    font-weight: 300;
    letter-spacing: 4px;
    color: var(--text);
  }

  #welcome-screen h1 span { color: var(--accent); font-weight: 500; }

  .welcome-drop-area {
    width: 400px;
    height: 220px;
    border: 2px dashed rgba(255,255,255,0.15);
    border-radius: 16px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 16px;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .welcome-drop-area:hover {
    border-color: var(--accent);
    background: var(--accent-dim);
  }

  .welcome-drop-area svg { opacity: 0.5; }
  .welcome-drop-area:hover svg { opacity: 1; }

  .welcome-drop-area p {
    font-size: 15px;
    color: var(--text-dim);
    font-weight: 300;
  }

  .welcome-drop-area .hint {
    font-size: 12px;
    color: rgba(255,255,255,0.25);
  }

  /* Loading */
  #loading-overlay {
    display: none;
    position: fixed;
    inset: 0;
    z-index: 900;
    background: rgba(0,0,0,0.9);
    justify-content: center;
    align-items: center;
    flex-direction: column;
    gap: 20px;
  }

  #loading-overlay.active { display: flex; }

  .loader {
    width: 48px; height: 48px;
    border: 3px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  #loading-text {
    font-size: 14px;
    color: var(--text-dim);
    font-weight: 300;
  }

  /* Menu Toggle */
  #menu-toggle {
    position: fixed;
    top: 16px;
    left: 16px;
    z-index: 200;
    width: 44px;
    height: 44px;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    display: none;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    color: var(--text);
  }

  #menu-toggle:hover {
    background: var(--bg-panel-hover);
    border-color: var(--accent);
    color: var(--accent);
  }

  #menu-toggle.visible { display: flex; }

  /* Side Panel */
  #side-panel {
    position: fixed;
    top: 0;
    left: 0;
    width: 340px;
    height: 100vh;
    background: var(--bg-panel);
    border-right: 1px solid var(--border);
    backdrop-filter: blur(20px);
    z-index: 300;
    transform: translateX(-100%);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    overflow-y: auto;
    padding: 20px;
  }

  #side-panel.open { transform: translateX(0); }

  #side-panel::-webkit-scrollbar { width: 4px; }
  #side-panel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }

  .panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 24px;
    padding-bottom: 16px;
    border-bottom: 1px solid var(--border);
  }

  .panel-header h2 {
    font-size: 16px;
    font-weight: 500;
    letter-spacing: 1px;
  }

  .panel-close {
    width: 32px; height: 32px;
    background: none;
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text-dim);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
  }

  .panel-close:hover { border-color: var(--danger); color: var(--danger); }

  .section {
    margin-bottom: 24px;
  }

  .section-title {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--text-dim);
    margin-bottom: 12px;
    font-weight: 500;
  }

  .btn {
    display: flex;
    align-items: center;
    gap: 8px;
    width: 100%;
    padding: 10px 14px;
    background: rgba(255,255,255,0.04);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    color: var(--text);
    font-size: 13px;
    font-family: var(--font);
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .btn:hover {
    background: var(--accent-dim);
    border-color: rgba(79, 195, 247, 0.3);
    color: var(--accent);
  }

  .btn svg { flex-shrink: 0; }

  .btn-accent {
    background: rgba(79, 195, 247, 0.1);
    border-color: rgba(79, 195, 247, 0.25);
    color: var(--accent);
  }

  .btn-accent:hover {
    background: rgba(79, 195, 247, 0.2);
  }

  /* Save Preset Form */
  .save-form {
    display: flex;
    gap: 8px;
  }

  .save-form input {
    flex: 1;
    padding: 9px 12px;
    background: rgba(255,255,255,0.04);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    color: var(--text);
    font-size: 13px;
    font-family: var(--font);
    outline: none;
    transition: border-color 0.2s;
  }

  .save-form input:focus { border-color: var(--accent); }

  .save-form input::placeholder { color: rgba(255,255,255,0.2); }

  .save-form select {
    width: 56px;
    padding: 9px 8px;
    background: rgba(255,255,255,0.04);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    color: var(--text);
    font-size: 13px;
    font-family: var(--mono);
    outline: none;
    transition: border-color 0.2s;
    cursor: pointer;
  }

  .save-form select:focus { border-color: var(--accent); }

  .preset-item .preset-slot-select {
    width: 56px;
    padding: 6px 8px;
    background: rgba(0,0,0,0.25);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    font-size: 12px;
    font-family: var(--mono);
    outline: none;
    cursor: pointer;
    flex-shrink: 0;
  }

  .preset-item .preset-slot-select:focus { border-color: rgba(79, 195, 247, 0.5); }


  .save-form button {
    padding: 9px 16px;
    background: var(--accent);
    border: none;
    border-radius: var(--radius);
    color: #000;
    font-size: 13px;
    font-weight: 500;
    font-family: var(--font);
    cursor: pointer;
    transition: opacity 0.2s;
    white-space: nowrap;
  }

  .save-form button:hover { opacity: 0.85; }

  /* Preset List */
  .preset-list {
    display: flex;
    flex-direction: column;
    gap: 6px;
    max-height: 300px;
    overflow-y: auto;
  }

  .preset-list::-webkit-scrollbar { width: 3px; }
  .preset-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.08); border-radius: 2px; }

  .preset-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: rgba(255,255,255,0.02);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    cursor: pointer;
    transition: all 0.2s;
  }

  .preset-item:hover {
    background: var(--accent-dim);
    border-color: rgba(79, 195, 247, 0.25);
  }

  .preset-item .preset-name {
    flex: 1;
    font-size: 13px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .preset-item .preset-coords {
    font-size: 10px;
    font-family: var(--mono);
    color: var(--text-dim);
  }

  .preset-item .preset-delete {
    width: 24px; height: 24px;
    background: none;
    border: none;
    color: var(--text-dim);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: all 0.2s;
    flex-shrink: 0;
  }

  .preset-item .preset-delete:hover {
    color: var(--danger);
    background: rgba(239, 83, 80, 0.15);
  }

  .empty-state {
    padding: 20px;
    text-align: center;
    color: var(--text-dim);
    font-size: 13px;
    font-weight: 300;
  }

  .btn-row {
    display: flex;
    gap: 8px;
  }

  .btn-row .btn { flex: 1; justify-content: center; }

  /* HUD */
  #hud {
    position: fixed;
    bottom: 16px;
    left: 50%;
    transform: translateX(-50%);
    display: none;
    gap: 24px;
    align-items: center;
    padding: 10px 20px;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    backdrop-filter: blur(12px);
    font-family: var(--mono);
    font-size: 12px;
    color: var(--text-dim);
    z-index: 100;
  }

  #hud.visible { display: flex; }

  #hud .hud-item { display: flex; align-items: center; gap: 6px; }
  #hud .hud-label { color: rgba(255,255,255,0.3); font-size: 10px; text-transform: uppercase; letter-spacing: 1px; }

  /* Crosshair */
  #crosshair {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 20px; height: 20px;
    z-index: 50;
    display: none;
    pointer-events: none;
  }

  #crosshair.visible { display: block; }

  #crosshair::before, #crosshair::after {
    content: '';
    position: absolute;
    background: rgba(255,255,255,0.4);
  }

  #crosshair::before {
    width: 1px; height: 20px;
    top: 0; left: 50%;
    transform: translateX(-50%);
  }

  #crosshair::after {
    width: 20px; height: 1px;
    top: 50%; left: 0;
    transform: translateY(-50%);
  }

  /* Controls hint */
  #controls-hint {
    position: fixed;
    bottom: 60px;
    left: 50%;
    transform: translateX(-50%);
    display: none;
    padding: 12px 20px;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    backdrop-filter: blur(12px);
    font-size: 13px;
    color: var(--text-dim);
    z-index: 100;
    text-align: center;
    line-height: 1.6;
    animation: fadeInUp 0.4s ease;
    white-space: nowrap;
  }

  #controls-hint.visible { display: block; }

  @keyframes fadeInUp {
    from { opacity: 0; transform: translate(-50%, 10px); }
    to { opacity: 1; transform: translate(-50%, 0); }
  }

  .key {
    display: inline-block;
    padding: 2px 7px;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 4px;
    font-family: var(--mono);
    font-size: 11px;
    color: var(--text);
    margin: 0 2px;
  }

  /* Notification */
  .notification {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 12px 20px;
    background: var(--bg-panel);
    border: 1px solid var(--accent);
    border-radius: var(--radius);
    color: var(--text);
    font-size: 13px;
    z-index: 1000;
    animation: slideIn 0.3s ease, slideOut 0.3s ease 2.5s forwards;
    backdrop-filter: blur(12px);
  }

  @keyframes slideIn { from { opacity: 0; transform: translateX(30px); } to { opacity: 1; transform: translateX(0); } }
  @keyframes slideOut { from { opacity: 1; } to { opacity: 0; transform: translateX(30px); } }

  /* File inputs (hidden) */
  .hidden-input { display: none; }

  /* Slider controls */
  .slider-group {
    margin-bottom: 14px;
  }

  .slider-label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: var(--text-dim);
    margin-bottom: 6px;
  }

  .slider-value {
    font-family: var(--mono);
    font-size: 12px;
    color: var(--accent);
    min-width: 36px;
    text-align: right;
  }

  input[type="range"] {
    -webkit-appearance: none;
    width: 100%;
    height: 4px;
    background: rgba(255,255,255,0.1);
    border-radius: 2px;
    outline: none;
    cursor: pointer;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    background: var(--accent);
    border-radius: 50%;
    border: none;
    cursor: pointer;
    transition: transform 0.15s;
  }

  input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.3);
  }

  /* Collapsible sections */
  .section-title.collapsible {
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 0;
    transition: color 0.2s;
  }

  .section-title.collapsible:hover { color: var(--accent); }

  .collapse-arrow {
    transition: transform 0.25s ease;
    flex-shrink: 0;
  }

  .section-title.collapsible.open .collapse-arrow {
    transform: rotate(180deg);
  }

  .collapsible-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease, opacity 0.25s ease;
    opacity: 0;
  }

  .collapsible-content.open {
    max-height: 800px;
    opacity: 1;
  }

  /* Matcap gallery */
  .matcap-thumb {
    width: 56px; height: 56px;
    border-radius: 6px;
    border: 2px solid transparent;
    cursor: grab;
    object-fit: cover;
    transition: border-color 0.15s, transform 0.15s;
    background: #222;
  }
  .matcap-thumb:hover {
    border-color: var(--accent);
    transform: scale(1.08);
  }
  .matcap-thumb.dragging {
    opacity: 0.5;
  }
  .matcap-assign-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 4px 8px;
    margin-bottom: 4px;
    background: rgba(255,255,255,0.05);
    border-radius: 4px;
    font-size: 12px;
  }
  .matcap-assign-item .matcap-assign-info {
    display: flex;
    align-items: center;
    gap: 6px;
    overflow: hidden;
  }
  .matcap-assign-item img {
    width: 24px; height: 24px;
    border-radius: 3px;
  }
  .matcap-assign-item .matcap-mat-name {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 140px;
  }
  .matcap-assign-item button {
    background: none;
    border: none;
    color: #f66;
    cursor: pointer;
    font-size: 14px;
    padding: 2px 4px;
  }
  #matcap-drop-indicator {
    position: fixed;
    display: none;
    pointer-events: none;
    border: 3px dashed var(--accent);
    border-radius: 12px;
    z-index: 9999;
    background: rgba(0,200,255,0.05);
  }
  .metalness-preset {
    width: 56px; height: 56px;
    border-radius: 6px;
    border: 2px solid rgba(255,255,255,0.15);
    cursor: grab;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: 600;
    font-family: var(--mono);
    color: var(--text);
    transition: border-color 0.15s, transform 0.15s;
    user-select: none;
    flex-shrink: 0;
    text-align: center;
    line-height: 1.2;
  }
  .metalness-preset:hover {
    border-color: var(--accent);
    transform: scale(1.08);
  }
  .metalness-preset.dragging { opacity: 0.5; }
  .metalness-preset[data-metalness="1"]   { background: linear-gradient(135deg, #555 0%, #ccc 40%, #fff 50%, #ccc 60%, #555 100%); color: #222; }
  .metalness-preset[data-metalness="0.5"] { background: linear-gradient(135deg, #444 0%, #888 40%, #aaa 50%, #888 60%, #444 100%); color: #fff; }
  .metalness-preset[data-metalness="0"]   { background: #333; color: #aaa; }


/* ===== ã‚¿ãƒƒãƒæ“ä½œUI ===== */
#touch-look-zone {
  position: fixed;
  top: 0; right: 0;
  width: 65%;
  height: 100%;
  z-index: 10;
  /* touch-action: none ã¯ JS ã§è¨­å®š */
}

#joystick-zone {
  position: fixed;
  bottom: 24px;
  left: 24px;
  width: 140px;
  height: 140px;
  z-index: 20;
  display: none; /* JS ã§è¡¨ç¤ºåˆ¶å¾¡ */
}

#touch-hint {
  position: fixed;
  bottom: 180px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.65);
  color: rgba(255,255,255,0.75);
  font-size: 13px;
  padding: 8px 16px;
  border-radius: 20px;
  z-index: 50;
  pointer-events: none;
  transition: opacity 1s ease;
  white-space: nowrap;
}

#touch-hint.hidden { opacity: 0; }

/* ãƒ—ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ï¼šã‚¿ãƒƒãƒæ™‚ã¯å¤§ãã */
.is-touch .preset-btn {
  min-height: 48px;
  font-size: 14px;
}

.is-touch #menu-toggle {
  width: 52px;
  height: 52px;
}

/* ã‚¿ãƒƒãƒæ™‚ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢ */
#welcome-touch-only {
  display: none;
}

.is-touch .welcome-drop-area {
  display: none;
}

.is-touch #welcome-touch-only {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
}

/* ä¸Šä¸‹ç§»å‹•ãƒœã‚¿ãƒ³ï¼ˆã‚¿ãƒƒãƒç”¨ï¼‰ */
#touch-vertical-btns {
  position: fixed;
  bottom: 24px;
  right: 24px;
  display: none;
  flex-direction: column;
  gap: 8px;
  z-index: 20;
}

#touch-vertical-btns button {
  width: 52px;
  height: 52px;
  border-radius: 50%;
  border: 1px solid rgba(255,255,255,0.25);
  background: rgba(15,15,20,0.8);
  color: white;
  font-size: 22px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
}

#touch-vertical-btns button:active {
  background: rgba(79,195,247,0.3);
}
</style>
</head>
<body>

<!-- ã‚¿ãƒƒãƒæ“ä½œã‚¾ãƒ¼ãƒ³ï¼ˆãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å¾Œã«æœ‰åŠ¹ï¼‰ -->
<div id="touch-look-zone" style="display:none;"></div>

<!-- ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‚¾ãƒ¼ãƒ³ -->
<div id="joystick-zone"></div>

<!-- ä¸Šä¸‹ç§»å‹•ãƒœã‚¿ãƒ³ï¼ˆã‚¿ãƒƒãƒç”¨ï¼‰ -->
<div id="touch-vertical-btns">
  <button id="btn-touch-up" title="ä¸Šã«ç§»å‹•">â†‘</button>
  <button id="btn-touch-down" title="ä¸‹ã«ç§»å‹•">â†“</button>
</div>

<!-- ã‚¿ãƒƒãƒæ“ä½œãƒ’ãƒ³ãƒˆ -->
<div id="touch-hint" class="hidden">å³ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼šè¦–ç‚¹å›è»¢ã€€å·¦ï¼šç§»å‹•</div>

<!-- Welcome Screen -->
<div id="welcome-screen">
  <h1>GLTF <span>ã‚¦ã‚©ãƒ¼ã‚¯ã‚¹ãƒ«ãƒ¼</span> ãƒ“ãƒ¥ãƒ¼ã‚¢</h1>
  <div class="welcome-drop-area" id="welcome-drop" onclick="document.getElementById('gltf-input-welcome').click()">
    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="color:var(--accent)">
      <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
      <polyline points="17 8 12 3 7 8"/>
      <line x1="12" y1="3" x2="12" y2="15"/>
    </svg>
    <p>GLTF / GLB ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ­ãƒƒãƒ—</p>
    <p class="hint">ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</p>
  </div>
  <input type="file" id="gltf-input-welcome" class="hidden-input" accept=".gltf,.glb">

  <!-- ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹ç”¨ãƒœã‚¿ãƒ³ï¼ˆPC ã§ã¯éè¡¨ç¤ºï¼‰ -->
  <div id="welcome-touch-only">
    <button onclick="document.getElementById('gltf-input-welcome').click()" style="
      padding: 18px 40px;
      font-size: 18px;
      font-family: var(--font);
      background: var(--accent);
      color: #000;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 1px;
    ">
      ğŸ“ GLBãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ
    </button>
    <p style="color:var(--text-dim); font-size:13px;">GLB / GLTF ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾å¿œ</p>
  </div>
</div>

<!-- Drop Overlay -->
<!-- Loading -->
<div id="loading-overlay">
  <div class="loader"></div>
  <div id="loading-text">ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
</div>

<!-- Canvas -->
<div id="canvas-container"></div>

<!-- Crosshair -->
<div id="crosshair"></div>

<!-- Menu Toggle -->
<button id="menu-toggle" title="ãƒ¡ãƒ‹ãƒ¥ãƒ¼">
  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
    <line x1="3" y1="6" x2="21" y2="6"/>
    <line x1="3" y1="12" x2="21" y2="12"/>
    <line x1="3" y1="18" x2="21" y2="18"/>
  </svg>
</button>

<!-- Side Panel -->
<div id="side-panel">
  <div class="panel-header">
    <h2>ãƒ¡ãƒ‹ãƒ¥ãƒ¼</h2>
    <button class="panel-close" id="panel-close" title="é–‰ã˜ã‚‹">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
        <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
      </svg>
    </button>
  </div>

  <!-- Camera Presets Section -->
  <div class="section">
    <div class="section-title">ã‚«ãƒ¡ãƒ©ãƒ—ãƒªã‚»ãƒƒãƒˆ</div>
    <div class="save-form">
      <select id="preset-slot-input" title="æ•°å­—ã‚­ãƒ¼å‰²ã‚Šå½“ã¦">
        <option value="">â€”</option>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
      </select>
      <input type="text" id="preset-name-input" placeholder="ãƒ—ãƒªã‚»ãƒƒãƒˆåã‚’å…¥åŠ›...">
      <button id="btn-save-preset">ä¿å­˜</button>
    </div>
  </div>

  <div class="section">
    <div class="section-title">ã‚«ãƒ¡ãƒ©è¨­å®š</div>
    <div class="slider-group">
      <label class="slider-label">
        <span>è¦–é‡è§’ï¼ˆFOVï¼‰</span>
        <span class="slider-value" id="val-fov">70</span>
      </label>
      <input type="range" id="slider-fov" min="20" max="120" step="1" value="70">
    </div>
    <div class="hint">â€» é€è¦–æŠ•å½±ï¼ˆPerspectiveï¼‰ã®ã¿æœ‰åŠ¹</div>
  </div>

  <div class="section">
    <div class="section-title">ä¿å­˜æ¸ˆã¿ãƒ—ãƒªã‚»ãƒƒãƒˆ</div>
    <div class="preset-list" id="preset-list">
      <div class="empty-state">ãƒ—ãƒªã‚»ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“</div>
    </div>
  </div>

  <div class="section">
    <div class="section-title">ãƒ—ãƒªã‚»ãƒƒãƒˆç®¡ç†</div>
    <div class="btn-row">
      <button class="btn" id="btn-export-presets">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
          <polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/>
        </svg>
        æ›¸ãå‡ºã—
      </button>
      <button class="btn" id="btn-import-presets" onclick="document.getElementById('json-input').click()">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
          <polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/>
        </svg>
        èª­ã¿è¾¼ã¿
      </button>
    </div>
    <input type="file" id="json-input" class="hidden-input" accept=".json">
  </div>

  <!-- Lighting Controls (collapsible) -->
  <div class="section">
    <div class="section-title collapsible" id="toggle-lighting">
      æ˜ã‚‹ã•èª¿æ•´
      <svg class="collapse-arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><polyline points="6 9 12 15 18 9"/></svg>
    </div>
    <div class="collapsible-content" id="lighting-content">
      <div class="slider-group">
        <label class="slider-label">
          <span>éœ²å‡º</span>
          <span class="slider-value" id="val-exposure">0.003</span>
        </label>
        <input type="range" id="slider-exposure" min="0" max="3.0" step="0.001" value="0.003">
      </div>
      <div class="slider-group">
        <label class="slider-label">
          <span>HDRåå°„ï¼ˆIBLï¼‰</span>
          <span class="slider-value" id="val-env-intensity">1000</span>
        </label>
        <input type="range" id="slider-env-intensity" min="0" max="50000" step="10" value="1000">
      </div>
      <div class="slider-group">
        <label class="slider-label">
          <span>èƒŒæ™¯æ˜ã‚‹ã•</span>
          <span class="slider-value" id="val-bg-intensity">500</span>
        </label>
        <input type="range" id="slider-bg-intensity" min="0" max="50000" step="10" value="500">
      </div>
      <div class="slider-group">
        <label class="slider-label">
          <span>ã‚¢ãƒ³ãƒ“ã‚¨ãƒ³ãƒˆ</span>
          <span class="slider-value" id="val-ambient">500</span>
        </label>
        <input type="range" id="slider-ambient" min="0" max="2000" step="1" value="500">
      </div>
      <div class="slider-group">
        <label class="slider-label">
          <span>ãƒ‡ã‚£ãƒ¬ã‚¯ã‚·ãƒ§ãƒŠãƒ«</span>
          <span class="slider-value" id="val-directional">500</span>
        </label>
        <input type="range" id="slider-directional" min="0" max="2000" step="1" value="500">
      </div>
      <div class="slider-group">
        <label class="slider-label">
          <span>ãƒ˜ãƒŸã‚¹ãƒ•ã‚£ã‚¢</span>
          <span class="slider-value" id="val-hemisphere">100</span>
        </label>
        <input type="range" id="slider-hemisphere" min="0" max="2000" step="1" value="100">
      </div>
    </div>
  </div>

  <!-- Light Position Controls (collapsible) -->
  <div class="section">
    <div class="section-title collapsible" id="toggle-lightpos">
      å…‰æºã®ä½ç½®ï¼ˆãƒ‡ã‚£ãƒ¬ã‚¯ã‚·ãƒ§ãƒŠãƒ«ï¼‰
      <svg class="collapse-arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><polyline points="6 9 12 15 18 9"/></svg>
    </div>
    <div class="collapsible-content" id="lightpos-content">
      <div class="slider-group">
        <label class="slider-label">
          <span>X</span>
          <span class="slider-value" id="val-light-x">5</span>
        </label>
        <input type="range" id="slider-light-x" min="-50" max="50" step="1" value="5">
      </div>
      <div class="slider-group">
        <label class="slider-label">
          <span>Yï¼ˆé«˜ã•ï¼‰</span>
          <span class="slider-value" id="val-light-y">5</span>
        </label>
        <input type="range" id="slider-light-y" min="-50" max="50" step="1" value="5">
      </div>
      <div class="slider-group">
        <label class="slider-label">
          <span>Z</span>
          <span class="slider-value" id="val-light-z">5</span>
        </label>
        <input type="range" id="slider-light-z" min="-50" max="50" step="1" value="5">
      </div>
    </div>
  </div>


  <!-- Postprocess Controls (collapsible) -->
  <div class="section">
    <div class="section-title collapsible" id="toggle-postfx">
      ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ã‚¹
      <svg class="collapse-arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><polyline points="6 9 12 15 18 9"/></svg>
    </div>
    <div class="collapsible-content" id="postfx-content">
      <label class="slider-label" style="margin-bottom:10px;">
        <input type="checkbox" id="chk-post-enable" style="margin-right:6px;"> æœ‰åŠ¹
      </label>
      <label class="slider-label" style="margin-top:8px;">
        <input type="checkbox" id="chk-post-bloom" style="margin-right:6px;" checked> Bloom
      </label>
      <div class="slider-group">
        <label class="slider-label"><span>Bloom å¼·ã•</span><span class="slider-value" id="val-bloom-strength">0.275</span></label>
        <input type="range" id="slider-bloom-strength" min="0" max="0.5" step="0.01" value="0.275">
      </div>
      <div class="slider-group">
        <label class="slider-label"><span>Bloom åŠå¾„</span><span class="slider-value" id="val-bloom-radius">0.175</span></label>
        <input type="range" id="slider-bloom-radius" min="0" max="1" step="0.01" value="0.175">
      </div>
      <div class="slider-group">
        <label class="slider-label"><span>Bloom ã—ãã„å€¤</span><span class="slider-value" id="val-bloom-threshold">0.85</span></label>
        <input type="range" id="slider-bloom-threshold" min="0" max="1" step="0.01" value="0.85">
      </div>

      <label class="slider-label" style="margin-top:8px;">
        <input type="checkbox" id="chk-post-dof" style="margin-right:6px;"> è¢«å†™ç•Œæ·±åº¦ï¼ˆDOFï¼‰
      </label>
      <div class="slider-group">
        <label class="slider-label"><span>ãƒ•ã‚©ãƒ¼ã‚«ã‚¹è·é›¢</span><span class="slider-value" id="val-dof-focus">10</span></label>
        <input type="range" id="slider-dof-focus" min="0.1" max="100" step="0.1" value="10">
      </div>
      <div class="slider-group">
        <label class="slider-label"><span>ã¼ã‘å¼·ã•</span><span class="slider-value" id="val-dof-strength">0.25</span></label>
        <input type="range" id="slider-dof-strength" min="0" max="1" step="0.01" value="0.25">
      </div>
      <div class="slider-group">
        <label class="slider-label"><span>æœ€å¤§ã¼ã‘</span><span class="slider-value" id="val-dof-maxblur">0.01</span></label>
        <input type="range" id="slider-dof-maxblur" min="0" max="0.05" step="0.001" value="0.01">
      </div>

      <label class="slider-label" style="margin-top:8px;">
        <input type="checkbox" id="chk-post-vignette" style="margin-right:6px;" checked> å‘¨è¾ºæ¸›å…‰
      </label>
      <div class="slider-group">
        <label class="slider-label"><span>ç¯„å›²</span><span class="slider-value" id="val-vignette-offset">1.0</span></label>
        <input type="range" id="slider-vignette-offset" min="0" max="2" step="0.01" value="1.0">
      </div>
      <div class="slider-group">
        <label class="slider-label"><span>æš—ã•</span><span class="slider-value" id="val-vignette-darkness">1.025</span></label>
        <input type="range" id="slider-vignette-darkness" min="0" max="2" step="0.01" value="1.025">
      </div>

      <label class="slider-label" style="margin-top:8px;">
        <input type="checkbox" id="chk-post-fxaa" style="margin-right:6px;" checked> FXAAï¼ˆã‚¢ãƒ³ãƒã‚¨ã‚¤ãƒªã‚¢ã‚¹ï¼‰
      </label>
    </div>
  </div>


  <!-- Spotlight Controls (collapsible) -->
  <div class="section">
    <div class="section-title collapsible" id="toggle-spotlight">
      ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆ
      <svg class="collapse-arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><polyline points="6 9 12 15 18 9"/></svg>
    </div>
    <div class="collapsible-content" id="spotlight-content">
      <button class="btn btn-accent" id="btn-add-spotlight" style="margin-bottom:10px">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
        ç¾åœ¨ä½ç½®ã«ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆè¿½åŠ 
      </button>
      <div id="spotlight-list" class="preset-list">
        <div class="empty-state">ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆãªã—</div>
      </div>
      <!-- Selected spotlight controls -->
      <div id="spotlight-edit" style="display:none; margin-top:12px;">
        <div class="section-title" style="margin-bottom:8px;">é¸æŠä¸­: <span id="spotlight-edit-name"></span></div>
        <div class="slider-group">
          <label class="slider-label"><span>å¼·ã•</span><span class="slider-value" id="val-sp-intensity">5000</span></label>
          <input type="range" id="slider-sp-intensity" min="100" max="10000" step="10" value="5000">
        </div>
        <div class="slider-group">
          <label class="slider-label"><span>è§’åº¦</span><span class="slider-value" id="val-sp-angle">45Â°</span></label>
          <input type="range" id="slider-sp-angle" min="5" max="90" step="1" value="45">
        </div>
        <div class="slider-group">
          <label class="slider-label"><span>ã¼ã‹ã—</span><span class="slider-value" id="val-sp-penumbra">0.3</span></label>
          <input type="range" id="slider-sp-penumbra" min="0" max="1" step="0.05" value="0.3">
        </div>
        <div class="slider-group">
          <label class="slider-label"><span>è·é›¢</span><span class="slider-value" id="val-sp-distance">30</span></label>
          <input type="range" id="slider-sp-distance" min="1" max="100" step="1" value="30">
        </div>
        <label class="slider-label" style="margin-top:8px;"><input type="checkbox" id="chk-sp-helpers" style="margin-right:6px;" checked> ãƒ˜ãƒ«ãƒ‘ãƒ¼è¡¨ç¤º</label>
      </div>
    </div>
  </div>

  <!-- Model Section (collapsed, bottom) -->
  <div class="section">
    <div class="section-title collapsible" id="toggle-model">
      ãƒ¢ãƒ‡ãƒ«
      <svg class="collapse-arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><polyline points="6 9 12 15 18 9"/></svg>
    </div>
    <div class="collapsible-content" id="model-content">
      <button class="btn" id="btn-load-gltf" onclick="document.getElementById('gltf-input').click()">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
          <polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/>
        </svg>
        èª­ã¿è¾¼ã¿
      </button>
      <input type="file" id="gltf-input" class="hidden-input" accept=".gltf,.glb">
    </div>
  </div>

  <!-- HDR Background Section (collapsed, bottom) -->
  <div class="section">
    <div class="section-title collapsible" id="toggle-hdr">
      èƒŒæ™¯ï¼ˆHDRï¼‰
      <svg class="collapse-arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><polyline points="6 9 12 15 18 9"/></svg>
    </div>
    <div class="collapsible-content" id="hdr-content">
      <button class="btn" id="btn-load-hdr" onclick="document.getElementById('hdr-input').click()">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
          <polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/>
        </svg>
        HDR èª­ã¿è¾¼ã¿
      </button>
      <input type="file" id="hdr-input" class="hidden-input" accept=".hdr">
      <div class="hint">â€» HDRåå°„/èƒŒæ™¯ã‚’é©ç”¨ã—ã¾ã™ã€‚0ã«ã™ã‚‹ã¨å®Œå…¨ã«å¤–ã‚Œã¾ã™ã€‚</div>
    </div>
  </div>

  <!-- Material Controls (collapsible) -->
  <div class="section">
    <div class="section-title collapsible" id="toggle-matcap">
      ãƒãƒ†ãƒªã‚¢ãƒ«
      <svg class="collapse-arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><polyline points="6 9 12 15 18 9"/></svg>
    </div>
    <div class="collapsible-content" id="matcap-content">
      <div class="hint" style="margin-bottom:8px">ã‚µãƒ ãƒã‚¤ãƒ«ã‚’3Dãƒ“ãƒ¥ãƒ¼ã«ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã§é©ç”¨</div>
      <div id="matcap-gallery" style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:10px;min-height:40px;align-items:center;">
        <div class="hint" id="matcap-loading">èª­ã¿è¾¼ã¿ä¸­...</div>
      </div>
      <button class="btn" id="btn-load-matcap" onclick="document.getElementById('matcap-file-input').click()" style="margin-bottom:8px">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
          <polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/>
        </svg>
        ãƒãƒƒãƒˆã‚­ãƒ£ãƒƒãƒ—è¿½åŠ 
      </button>
      <input type="file" id="matcap-file-input" class="hidden-input" accept=".png,.jpg,.jpeg,.exr">
      <div class="section-title" style="margin:10px 0 6px">é©ç”¨ä¸­</div>
      <div id="matcap-assignments" class="preset-list" style="min-height:24px;">
        <div class="hint">ãªã—</div>
      </div>
      <button class="btn" id="btn-clear-all-matcap" style="margin-top:8px">ã™ã¹ã¦è§£é™¤</button>
    </div>
  </div>
</div>

<!-- HUD -->
<div id="hud">
  <div class="hud-item">
    <span class="hud-label">X</span>
    <span id="hud-x">0.00</span>
  </div>
  <div class="hud-item">
    <span class="hud-label">Y</span>
    <span id="hud-y">0.00</span>
  </div>
  <div class="hud-item">
    <span class="hud-label">Z</span>
    <span id="hud-z">0.00</span>
  </div>
  <div class="hud-item">
    <span class="hud-label">FPS</span>
    <span id="hud-fps">0</span>
  </div>
</div>

<!-- Controls Hint -->
<div id="matcap-drop-indicator"></div>
<div id="controls-hint">
  <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> ç§»å‹• &nbsp;
  <span class="key">Space</span> ä¸Šæ˜‡ &nbsp;
  <span class="key">Shift</span>+<span class="key">Space</span> ä¸‹é™ &nbsp;
  <span class="key">M</span> ãƒ¡ãƒ‹ãƒ¥ãƒ¼ &nbsp;
  <span class="key">ESC</span> ãƒã‚¤ãƒ³ã‚¿ãƒ¼è§£é™¤
</div>

<!-- nipple.js: ã‚¿ãƒƒãƒã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ -->
<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.2/distribution/nipplejs.min.js"></script>

<!-- ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹åˆ¤å®š + Service Workerç™»éŒ² -->
<script>
const IS_TOUCH = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js').catch(() => {});
  });
}
</script>

<!-- Three.js -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
import { VignetteShader } from 'three/addons/shaders/VignetteShader.js';


// ===== App State =====
const state = {
  scene: null,
  camera: null,
  renderer: null,
  composer: null,
  post: { renderPass: null, dofPass: null, bloomPass: null, vignettePass: null, fxaaPass: null, outputPass: null },
  postEnabled: false,
  envIntensity: 1000,
  bgIntensity: 500,
  envMap: null,  // HDRãƒ†ã‚¯ã‚¹ãƒãƒ£å‚ç…§ã‚’ä¿æŒ
  envRT: null,
  currentModel: null,
  presets: [],
  isPointerLocked: false,
  modelLoaded: false,
  panelOpen: false,
  keys: {},
  euler: new THREE.Euler(0, 0, 0, 'YXZ'),
  moveSpeed: 5.0,
  mouseSensitivity: 0.002,
  fpsTimes: [],
  currentFps: 0,
  lights: { ambient: null, directional: null, hemisphere: null },
  spotlights: [],
  selectedSpotlight: -1,
  showHelpers: true,
  // Matcap
  matcapAssignments: {},   // materialName â†’ { file, texture }
  matcapOriginals: {},     // materialName â†’ originalMaterial
  matcapTextures: {},      // filename â†’ THREE.Texture (cache)
  matcapFiles: [],         // list of available matcap files
  // Metalness
  metalnessAssignments: {},   // materialName â†’ metalness value
  metalnessOriginals: {},     // materialName â†’ original metalness value
  roughnessOriginals: {},     // materialName â†’ original roughness value
  // Clearcoat / exposure-immune reflection (for reflection presets)
  clearcoatOriginals: {},            // materialName â†’ original clearcoat
  clearcoatRoughnessOriginals: {},   // materialName â†’ original clearcoatRoughness
  toneMappedOriginals: {},           // materialName â†’ original toneMapped
  clearcoatOriginalMaterials: {},    // materialName â†’ original material (when upgraded Standardâ†’Physical)
};


// ===== DOM Elements =====
const dom = {
  container: document.getElementById('canvas-container'),
  welcome: document.getElementById('welcome-screen'),
  loadingOverlay: document.getElementById('loading-overlay'),
  loadingText: document.getElementById('loading-text'),
  menuToggle: document.getElementById('menu-toggle'),
  sidePanel: document.getElementById('side-panel'),
  panelClose: document.getElementById('panel-close'),
  presetList: document.getElementById('preset-list'),
  presetNameInput: document.getElementById('preset-name-input'),
  presetSlotInput: document.getElementById('preset-slot-input'),
  btnSavePreset: document.getElementById('btn-save-preset'),
  btnExportPresets: document.getElementById('btn-export-presets'),
  gltfInput: document.getElementById('gltf-input'),
  gltfInputWelcome: document.getElementById('gltf-input-welcome'),
  jsonInput: document.getElementById('json-input'),
  hud: document.getElementById('hud'),
  hudX: document.getElementById('hud-x'),
  hudY: document.getElementById('hud-y'),
  hudZ: document.getElementById('hud-z'),
  hudFps: document.getElementById('hud-fps'),
  crosshair: document.getElementById('crosshair'),
  controlsHint: document.getElementById('controls-hint'),
};

// ===== Three.js Setup =====
function initThree() {
  state.scene = new THREE.Scene();
  state.scene.backgroundIntensity = state.bgIntensity;

  state.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 2000);
  state.camera.position.set(0, 1.6, 0);

  state.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance', alpha: true });
  state.renderer.setClearColor(0x000000, 0);
  state.renderer.setSize(window.innerWidth, window.innerHeight);
  state.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  state.renderer.outputColorSpace = THREE.SRGBColorSpace;
  state.renderer.toneMapping = THREE.ACESFilmicToneMapping;
  state.renderer.toneMappingExposure = 0.003;
  state.renderer.shadowMap.enabled = true;
  state.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  dom.container.appendChild(state.renderer.domElement);

  // èƒŒæ™¯ã¯HDRIã‚’ä½¿ç”¨ï¼ˆèƒŒæ™¯ï¼‹åå°„/IBLï¼‰
  initEnvironmentHDR();


  // Lightingï¼ˆHDRç’°å¢ƒã«åˆã‚ã›ãŸåˆæœŸå€¤ â€” IBLãŒä¸»å…‰æºã¨ãªã‚‹ãŸã‚ä½ã‚ã«ï¼‰
  state.lights.ambient = new THREE.AmbientLight(0xffffff, 500);
  state.scene.add(state.lights.ambient);

  // ãƒ‡ã‚£ãƒ¬ã‚¯ã‚·ãƒ§ãƒŠãƒ«ãƒ©ã‚¤ãƒˆ - å¹³è¡Œå…‰ç·šï¼ˆå¤ªé™½å…‰ï¼‰
  state.lights.directional = new THREE.DirectionalLight(0xffffff, 500);
  state.lights.directional.position.set(5, 5, 5);
  state.lights.directional.castShadow = true;
  state.lights.directional.shadow.mapSize.width = 4096;
  state.lights.directional.shadow.mapSize.height = 4096;
  state.lights.directional.shadow.camera.near = 0.5;
  state.lights.directional.shadow.camera.far = 200;
  state.lights.directional.shadow.camera.left = -50;
  state.lights.directional.shadow.camera.right = 50;
  state.lights.directional.shadow.camera.top = 50;
  state.lights.directional.shadow.camera.bottom = -50;
  state.lights.directional.shadow.bias = 0;
  state.lights.directional.shadow.normalBias = 0.1;
  state.scene.add(state.lights.directional);

  // ãƒ˜ãƒŸã‚¹ãƒ•ã‚£ã‚¢ãƒ©ã‚¤ãƒˆ - ç©ºã¨åœ°é¢ã‹ã‚‰ã®å…‰
  state.lights.hemisphere = new THREE.HemisphereLight(0xffffff, 0xffffff, 100);
  state.scene.add(state.lights.hemisphere);

  window.addEventListener('resize', onResize);

  initPostprocessing();
}


// ===== HDRI Background / Environment (Reflections) =====
async function initEnvironmentHDR() {
  const hdrUrl = 'Background.hdr';
  if (!state.scene || !state.renderer) return;

  // file:// ã¾ãŸã¯GitHub Pagesï¼ˆHDRãƒ•ã‚¡ã‚¤ãƒ«ãªã—ï¼‰ã¯ã‚¹ã‚­ãƒƒãƒ—
  if (location.protocol === 'file:') return;

  // HEADãƒªã‚¯ã‚¨ã‚¹ãƒˆã§å­˜åœ¨ç¢ºèªã—ã¦ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰
  try {
    const check = await fetch(hdrUrl, { method: 'HEAD' });
    if (!check.ok) return; // 404ãªã‚‰é™ã‹ã«ã‚¹ã‚­ãƒƒãƒ—
  } catch {
    return;
  }

  try {
    const loader = new RGBELoader();
    loader.setDataType(THREE.HalfFloatType);
    const hdrEquirect = await loader.loadAsync(hdrUrl);
    setEnvironmentFromEquirect(hdrEquirect);
  } catch (e) {
    console.warn('HDRI auto-load failed:', e);
  }
}

function setEnvironmentFromEquirect(hdrEquirect) {
  if (!hdrEquirect || !state.renderer || !state.scene) return;

  const pmrem = new THREE.PMREMGenerator(state.renderer);
  pmrem.compileEquirectangularShader();

  const envRT = pmrem.fromEquirectangular(hdrEquirect);
  const envMap = envRT.texture;

  hdrEquirect.dispose();
  pmrem.dispose();

  if (state.envRT) {
    try { state.envRT.dispose(); } catch {}
  }
  state.envRT = envRT;
  state.envMap = envMap;

  // èƒŒæ™¯ç”¨
  state.scene.background = envMap;
  state.scene.backgroundIntensity = state.bgIntensity ?? 1.0;

  // scene.environment ã‚‚è¨­å®šï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
  state.scene.environment = envMap;
  state.scene.environmentIntensity = 1.0;

  // === æ ¸å¿ƒï¼šmaterial.envMap ã‚’ç›´æ¥è¨­å®šï¼ˆ1å›ã ã‘ needsUpdateï¼‰ ===
  if (state.currentModel) {
    const exp = Math.max(state.renderer.toneMappingExposure, 0.0001);
    const intensity = state.envIntensity;
    let count = 0;
    state.currentModel.traverse((o) => {
      if (!o?.isMesh) return;
      const mats = Array.isArray(o.material) ? o.material : [o.material];
      mats.forEach((m) => {
        if (!m) return;
        if (m.isMeshStandardMaterial || m.isMeshPhysicalMaterial) {

          // ãƒ™ãƒ¼ã‚¹ï¼ˆå…ƒã®ï¼‰IBLå¼·åº¦ã‚’ä¿å­˜ï¼ˆåˆå›ã®ã¿ï¼‰
          if (!m.userData) m.userData = {};
          if (m.userData.__baseEnvMapIntensity === undefined) {
            m.userData.__baseEnvMapIntensity = (typeof m.envMapIntensity === 'number') ? m.envMapIntensity : 1.0;
          }

          m.envMap = envMap; // ç›´æ¥ä»£å…¥

          // ã€Œåå°„ãƒ—ãƒªã‚»ãƒƒãƒˆé©ç”¨ï¼ˆãƒãƒ†ãƒªã‚¢ãƒ«å¤‰æ›´ï¼‰ã€ã®ã¿ã€HDRåå°„ï¼ˆIBLï¼‰ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’é©ç”¨ã™ã‚‹
          const isTarget = (m.name && state.metalnessAssignments && state.metalnessAssignments[m.name] !== undefined);
          m.envMapIntensity = isTarget ? intensity : m.userData.__baseEnvMapIntensity;

          m.needsUpdate = true; // ã‚·ã‚§ãƒ¼ãƒ€å†ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ï¼ˆ1å›ã®ã¿ï¼‰
          count++;
        }
      });
    });
    console.log(`[HDR] envMap directly assigned to ${count} material(s). intensity=${intensity} (exposure=${exp})`);
  }

  notify('HDR ã‚’é©ç”¨ã—ã¾ã—ãŸ');
}

// === ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼å¤‰æ›´æ™‚ï¼šenvMapIntensity ã®ã¿æ›´æ–°ï¼ˆneedsUpdate ä¸è¦ï¼‰===
function updateEnvIntensity() {
  if (!state.currentModel) return;

  const v = state.envIntensity;

  state.currentModel.traverse((o) => {
    if (!o?.isMesh) return;

    const mats = Array.isArray(o.material) ? o.material : [o.material];
    mats.forEach((m) => {
      if (!m) return;
      if (m.envMapIntensity === undefined) return;

      // ãƒ™ãƒ¼ã‚¹ï¼ˆå…ƒã®ï¼‰IBLå¼·åº¦ã‚’ä¿å­˜ï¼ˆåˆå›ã®ã¿ï¼‰
      if (!m.userData) m.userData = {};
      if (m.userData.__baseEnvMapIntensity === undefined) {
        m.userData.__baseEnvMapIntensity = (typeof m.envMapIntensity === 'number') ? m.envMapIntensity : 1.0;
      }

      // ã€Œåå°„ãƒ—ãƒªã‚»ãƒƒãƒˆé©ç”¨ï¼ˆãƒãƒ†ãƒªã‚¢ãƒ«å¤‰æ›´ï¼‰ã€ã®ã¿ã€HDRåå°„ï¼ˆIBLï¼‰ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’é©ç”¨ã™ã‚‹
      const isTarget = (m.name && state.metalnessAssignments && state.metalnessAssignments[m.name] !== undefined);
      m.envMapIntensity = isTarget ? v : m.userData.__baseEnvMapIntensity;
      // needsUpdate ã¯å‘¼ã°ãªã„ï¼ˆenvMapIntensity ã¯ uniformï¼‰
    });
  });

  // NOTE: scene.environment / background ã¯ã“ã“ã§ã¯è§¦ã‚‰ãªã„
  // ï¼ˆHDRåå°„ï¼ˆIBLï¼‰ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’å…¨ä½“ã¸é©ç”¨ã—ãªã„ãŸã‚ï¼‰
}

function applyEnvMapToAllMaterials() { updateEnvIntensity(); }

function applyEnvMapIntensityToAllMaterials() { updateEnvIntensity(); }

// ===== Postprocessing =====
function initPostprocessing() {
  state.composer = null;
  state.post = { renderPass: null, dofPass: null, bloomPass: null, vignettePass: null, fxaaPass: null, outputPass: null };

  const size = new THREE.Vector2();
  state.renderer.getSize(size);
  const pixelRatio = Math.min(window.devicePixelRatio, 2);

  const composer = new EffectComposer(state.renderer);
  composer.setSize(size.x, size.y);
  if (composer.setPixelRatio) composer.setPixelRatio(pixelRatio);

  // â‘  é€šå¸¸ãƒ¬ãƒ³ãƒ€ãƒ¼
  const renderPass = new RenderPass(state.scene, state.camera);
  composer.addPass(renderPass);

  // â‘¡ è¢«å†™ç•Œæ·±åº¦ï¼ˆDOFï¼‰
  const DOF_APERTURE_SCALE = 0.00008; // UI(0-1) â†’ aperture å¤‰æ›ä¿‚æ•°
  const dofPass = new BokehPass(state.scene, state.camera, {
    focus: 10.0,
    aperture: 0.25 * DOF_APERTURE_SCALE,
    maxblur: 0.01,
    width: size.x,
    height: size.y,
  });
  dofPass.enabled = false;
  composer.addPass(dofPass);

  // â‘¡ Bloom
  const bloomPass = new UnrealBloomPass(new THREE.Vector2(size.x, size.y), 0.275, 0.175, 0.85);
  composer.addPass(bloomPass);

  // â‘¢ ã†ã£ã™ã‚‰å‘¨è¾ºæ¸›å…‰
  const vignettePass = new ShaderPass(VignetteShader);
  vignettePass.uniforms['offset'].value = 1.0;
  vignettePass.uniforms['darkness'].value = 1.025;
  composer.addPass(vignettePass);

  // â‘£ FXAA
  const fxaaPass = new ShaderPass(FXAAShader);
  const pr = state.renderer.getPixelRatio();
  fxaaPass.material.uniforms['resolution'].value.set(1 / (size.x * pr), 1 / (size.y * pr));
  composer.addPass(fxaaPass);

  // â‘¤ è‰²ç®¡ç†ï¼ˆtone mapping / outputColorSpaceï¼‰
  const outputPass = new OutputPass();
  composer.addPass(outputPass);

  // UIçŠ¶æ…‹ï¼ˆå­˜åœ¨ã™ã‚Œã°ï¼‰ã‚’åæ˜ 
  const chkEnable = document.getElementById('chk-post-enable');
  const chkBloom = document.getElementById('chk-post-bloom');
  const chkDOF = document.getElementById('chk-post-dof');
  const chkVignette = document.getElementById('chk-post-vignette');
  const chkFXAA = document.getElementById('chk-post-fxaa');

  if (chkEnable) state.postEnabled = chkEnable.checked;
  if (chkBloom) bloomPass.enabled = chkBloom.checked;
  if (chkDOF) dofPass.enabled = chkDOF.checked;
  if (chkVignette) vignettePass.enabled = chkVignette.checked;
  if (chkFXAA) fxaaPass.enabled = chkFXAA.checked;

  state.composer = composer;
  state.post = { renderPass, dofPass, bloomPass, vignettePass, fxaaPass, outputPass };
}

function syncPostprocessingCamera() {
  if (!state.post) return;
  if (state.post.renderPass) state.post.renderPass.camera = state.camera;
  if (state.post.dofPass) state.post.dofPass.camera = state.camera;
}

function resizePostprocessing() {
  if (!state.composer) return;
  const w = window.innerWidth;
  const h = window.innerHeight;
  const pixelRatio = Math.min(window.devicePixelRatio, 2);
  state.composer.setSize(w, h);
  if (state.composer.setPixelRatio) state.composer.setPixelRatio(pixelRatio);

  const pr = state.renderer.getPixelRatio();
  if (state.post?.fxaaPass) {
    state.post.fxaaPass.material.uniforms['resolution'].value.set(1 / (w * pr), 1 / (h * pr));
  }
  if (state.post?.dofPass?.setSize) state.post.dofPass.setSize(w, h);
  if (state.post?.bloomPass?.setSize) state.post.bloomPass.setSize(w, h);
}

function onResize() {
  const aspect = window.innerWidth / window.innerHeight;

  if (state.camera?.isPerspectiveCamera) {
    state.camera.aspect = aspect;
  } else if (state.camera?.isOrthographicCamera) {
    // ç¸¦æ–¹å‘ã®ç”»è§’ï¼ˆtop-bottomï¼‰ã‚’ç¶­æŒã—ã€æ¨ªæ–¹å‘ã‚’ã‚¢ã‚¹ãƒšã‚¯ãƒˆã«åˆã‚ã›ã‚‹
    const height = state.camera.top - state.camera.bottom;
    const halfH = height / 2;
    const halfW = halfH * aspect;
    state.camera.left = -halfW;
    state.camera.right = halfW;
  }

  state.camera.updateProjectionMatrix();
  state.renderer.setSize(window.innerWidth, window.innerHeight);
  resizePostprocessing();
}

// ===== GLTFå†…ã‚«ãƒ¡ãƒ©ã®é©ç”¨ =====
function applyGltfCameraIfPresent(gltf) {
  if (!gltf || !gltf.scene) return false;

  // glTFå†…ã®ã‚«ãƒ¡ãƒ©ãƒãƒ¼ãƒ‰ã‚’æ¢ã™ï¼ˆæœ€åˆã«è¦‹ã¤ã‹ã£ãŸã‚‚ã®ã‚’æ¡ç”¨ï¼‰
  let camNode = null;
  gltf.scene.updateMatrixWorld(true);
  gltf.scene.traverse((o) => {
    if (!camNode && o && o.isCamera) camNode = o;
  });
  if (!camNode) return false;

  const wpos = new THREE.Vector3();
  const wquat = new THREE.Quaternion();
  camNode.getWorldPosition(wpos);
  camNode.getWorldQuaternion(wquat);

  // æŠ•å½±ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’åæ˜ ï¼ˆPerspectiveå„ªå…ˆã€‚Orthographicã®å ´åˆã¯state.cameraã‚’ç½®ãæ›ãˆï¼‰
  if (camNode.isPerspectiveCamera) {
    if (!state.camera?.isPerspectiveCamera) {
      state.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 2000);
    }
    state.camera.fov = camNode.fov;
    state.camera.near = camNode.near;
    state.camera.far = camNode.far;
    state.camera.zoom = camNode.zoom;
    state.camera.aspect = window.innerWidth / window.innerHeight;
    state.camera.updateProjectionMatrix();
  } else if (camNode.isOrthographicCamera) {
    const aspect = window.innerWidth / window.innerHeight;
    const height = camNode.top - camNode.bottom;
    const halfH = height / 2;
    const halfW = halfH * aspect;
    state.camera = new THREE.OrthographicCamera(-halfW, halfW, halfH, -halfH, camNode.near, camNode.far);
    state.camera.updateProjectionMatrix();
  }

  // ä½ç½®ãƒ»å‘ãã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã§åæ˜ 
  state.camera.position.copy(wpos);
  state.camera.quaternion.copy(wquat);

  // FPSç”¨ã®eulerã‚‚åŒæœŸ
  state.euler.setFromQuaternion(state.camera.quaternion);

  // ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ã‚¹å´ã«ã‚‚æ–°ã—ã„ã‚«ãƒ¡ãƒ©å‚ç…§ã‚’åæ˜ 
  syncPostprocessingCamera();

  updateFovUI();

  return true;
}

// ===== GLTF Loading =====

// URLã‹ã‚‰ç›´æ¥GLTFã‚’èª­ã¿è¾¼ã‚€ï¼ˆè‡ªå‹•èª­ã¿è¾¼ã¿ / URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç”¨ï¼‰
function loadGLTFFromURL(url, fileName) {
  showLoading(true);
  dom.loadingText.textContent = `${fileName || 'ãƒ¢ãƒ‡ãƒ«'}ã‚’èª­ã¿è¾¼ã¿ä¸­...`;

  if (state.currentModel) {
    state.scene.remove(state.currentModel);
    disposeModel(state.currentModel);
    state.currentModel = null;
  }

  const loader = new GLTFLoader();
  const dracoLoader = new DRACOLoader();
  dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/libs/draco/');
  loader.setDRACOLoader(dracoLoader);

  loader.load(
    url,
    (gltf) => {
      onGLTFLoaded(gltf, fileName);
    },
    (progress) => {
      if (progress.total > 0) {
        const pct = Math.round((progress.loaded / progress.total) * 100);
        dom.loadingText.textContent = `${fileName || 'èª­ã¿è¾¼ã¿ä¸­'}... ${pct}%`;
      }
    },
    (error) => {
      console.error('GLTF load error:', error);
      showLoading(false);
      notify(`${fileName || 'ãƒ¢ãƒ‡ãƒ«'}ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ`);
    }
  );
}

// GLTFèª­ã¿è¾¼ã¿å¾Œã®å…±é€šå‡¦ç†
function removeObjectsNamed(root, targetName) {
  if (!root || !targetName) return 0;
  const targetLower = String(targetName).toLowerCase();
  const toRemove = [];
  root.traverse((o) => {
    if (!o?.name) return;
    if (String(o.name).toLowerCase() === targetLower) toRemove.push(o);
  });
  toRemove.forEach((o) => {
    if (!o.parent) return; // root ãªã©ã¯å‰Šé™¤ã§ããªã„
    // ãƒ¡ãƒƒã‚·ãƒ¥ã‚’å«ã‚€å ´åˆã«å‚™ãˆã¦ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾ï¼ˆdisposeModel ã¯ mesh ã®ã¿å¯¾è±¡ï¼‰
    try { disposeModel(o); } catch (_) {}
    o.parent.remove(o);
  });
  if (toRemove.length > 0) {
    console.log(`[Model] Removed ${toRemove.length} object(s) named "${targetName}"`);
  }
  return toRemove.length;
}

// ãƒãƒ†ãƒªã‚¢ãƒ«åã‚’ãƒ¦ãƒ‹ãƒ¼ã‚¯ã«è£œå®Œï¼ˆåå‰ãªã—/é‡è¤‡å¯¾ç­–ï¼‰
// Matcap ã®é©ç”¨ã‚­ãƒ¼ï¼ˆmaterial.nameï¼‰ã¨ã—ã¦ä½¿ã†ãŸã‚ã€ç©º/é‡è¤‡ã‚’é¿ã‘ã‚‹ã€‚
function ensureUniqueMaterialNames(root) {
  if (!root) return;
  const used = new Map();          // baseName -> count
  const seen = new WeakMap();      // material -> uniqueName
  let autoIndex = 1;

  root.traverse((o) => {
    if (!o?.isMesh || !o.material) return;
    const mats = Array.isArray(o.material) ? o.material : [o.material];

    for (const m of mats) {
      if (!m) continue;

      // æ—¢ã«å‰²ã‚Šå½“ã¦æ¸ˆã¿ãªã‚‰å†åˆ©ç”¨
      if (seen.has(m)) {
        m.name = seen.get(m);
        continue;
      }

      let base = (m.name || '').trim();
      if (!base) {
        base = `Material_${String(autoIndex).padStart(3, '0')}`;
        autoIndex++;
      }

      const c = (used.get(base) || 0) + 1;
      used.set(base, c);
      const unique = (c === 1) ? base : `${base}__${c}`;

      m.name = unique;
      seen.set(m, unique);
    }
  });
}

function onGLTFLoaded(gltf, label) {
  state.currentModel = gltf.scene;

  // Matcap/MetalnessçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆãƒ¢ãƒ‡ãƒ«å†èª­è¾¼æ™‚ï¼‰
  state.matcapAssignments = {};
  state.matcapOriginals = {};
  state.metalnessAssignments = {};
  state.metalnessOriginals = {};
  state.roughnessOriginals = {};
  renderAllAssignments();

  // GLBå†…ã®ãƒ©ã‚¤ãƒˆã‚’ã™ã¹ã¦å‰Šé™¤ï¼ˆè‡ªå‰ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ã¨ã®ç«¶åˆé˜²æ­¢ï¼‰
  const lightsToRemove = [];
  state.currentModel.traverse((obj) => {
    if (obj.isLight) lightsToRemove.push(obj);
  });
  if (lightsToRemove.length > 0) {
    lightsToRemove.forEach((light) => {
      console.log(`[Model] Removed light: "${light.name || '(unnamed)'}" (${light.type})`);
      if (light.parent) light.parent.remove(light);
      if (light.dispose) light.dispose();
    });
    console.log(`[Model] ${lightsToRemove.length} light(s) removed from GLB`);
  }

  state.currentModel.traverse((child) => {
    if (child.isMesh) {
      // å½±è¨­å®š
      child.receiveShadow = true;

      // ãƒãƒ†ãƒªã‚¢ãƒ«èª¿æ•´
      const processMaterial = (src) => {
        if (!src) return src;
        // HDRãŒæ—¢ã«ãƒ­ãƒ¼ãƒ‰æ¸ˆã¿ãªã‚‰ envMap ã‚’ç›´æ¥è¨­å®š
        if ((src.isMeshStandardMaterial || src.isMeshPhysicalMaterial) && state.envMap) {
          src.envMap = state.envMap;

          // éã‚¿ãƒ¼ã‚²ãƒƒãƒˆæã¯ã€Œå…ƒã®IBLå¼·åº¦ã€ã‚’ç¶­æŒã—ã€åå°„ãƒ—ãƒªã‚»ãƒƒãƒˆã§å¤‰æ›´ã—ãŸæã ã‘ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼å€¤ã‚’å½“ã¦ã‚‹
          if (!src.userData) src.userData = {};
          if (src.userData.__baseEnvMapIntensity === undefined) {
            src.userData.__baseEnvMapIntensity = (typeof src.envMapIntensity === 'number') ? src.envMapIntensity : 1.0;
          }

          const isTarget = (src.name && state.metalnessAssignments && state.metalnessAssignments[src.name] !== undefined);
          src.envMapIntensity = isTarget ? state.envIntensity : src.userData.__baseEnvMapIntensity;
        }
src.needsUpdate = true;
        return src;
      };

      if (Array.isArray(child.material)) {
        child.material = child.material.map(m => processMaterial(m));
      } else {
        child.material = processMaterial(child.material);
      }

      // åŠé€æ˜åˆ¤å®šï¼ˆã‚¬ãƒ©ã‚¹ç­‰ã¯å½±ã‚’è½ã¨ã•ãªã„ï¼‰
      const mats = Array.isArray(child.material) ? child.material : [child.material];
      const isTranslucent = mats.some(m => {
        if (!m) return false;
        if (m.isMeshPhysicalMaterial && m.transmission > 0) return true;
        if (m.transparent && m.opacity < 0.99) return true;
        if (m.alphaMap) return true;
        return false;
      });
      child.castShadow = !isTranslucent;
    }
  });

    // Matcapé©ç”¨ã®ãŸã‚ã« material.name ã‚’è£œå®Œ
  ensureUniqueMaterialNames(state.currentModel);

// ãƒãƒ†ãƒªã‚¢ãƒ«è¨ºæ–­ãƒ­ã‚°
  const matTypes = {};
  state.currentModel.traverse(o => {
    if (o.isMesh) {
      const mats = Array.isArray(o.material) ? o.material : [o.material];
      mats.forEach(m => {
        if (!m) return;
        const type = m.type || m.constructor.name;
        matTypes[type] = (matTypes[type] || 0) + 1;
        if (m.isMeshStandardMaterial || m.isMeshPhysicalMaterial) {
          console.log(`[Model] Material "${m.name}": type=${type}, metalness=${m.metalness}, roughness=${m.roughness}, envMap=${!!m.envMap}, envMapIntensity=${m.envMapIntensity}`);
        }
      });
    }
  });
  console.log('[Model] Material types:', matTypes);

  state.scene.add(state.currentModel);

  if (state.presets.length > 0) {
    applyCameraPreset(state.presets[0]);
  } else {
    const applied = applyGltfCameraIfPresent(gltf);
    if (!applied) {
      state.camera.position.set(0, 1.6, 0);
      state.euler.set(0, 0, 0);
      state.camera.rotation.copy(state.euler);
      updateFovUI();
    } else {
      notify('ãƒ¢ãƒ‡ãƒ«å†…ã‚«ãƒ¡ãƒ©ã‚’é©ç”¨ã—ã¾ã—ãŸ');
    }
  }

  state.modelLoaded = true;
  dom.welcome.classList.add('hidden');
  dom.menuToggle.classList.add('visible');
  dom.hud.classList.add('visible');
  dom.crosshair.classList.add('visible');
  dom.controlsHint.classList.add('visible');
  setTimeout(() => { dom.controlsHint.classList.remove('visible'); }, 8000);

  // ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹ã®å ´åˆã€æ“ä½œãƒ’ãƒ³ãƒˆã‚’è¡¨ç¤º
  if (IS_TOUCH) showTouchHint();

    // envåå°„ï¼šscene.environmentIntensity ã‚’æ›´æ–°
  updateEnvIntensity();

  showLoading(false);
  notify(`${label || 'ãƒ¢ãƒ‡ãƒ«'}ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
}

// ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰GLTFã‚’èª­ã¿è¾¼ã‚€ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ— / ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠç”¨ï¼‰
function loadGLTF(file) {
  showLoading(true);

  if (state.currentModel) {
    state.scene.remove(state.currentModel);
    disposeModel(state.currentModel);
    state.currentModel = null;
  }

  const url = URL.createObjectURL(file);
  const loader = new GLTFLoader();
  const dracoLoader = new DRACOLoader();
  dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/libs/draco/');
  loader.setDRACOLoader(dracoLoader);

  loader.load(
    url,
    (gltf) => {
      URL.revokeObjectURL(url);
      onGLTFLoaded(gltf, file.name);
    },
    (progress) => {
      if (progress.total > 0) {
        const pct = Math.round((progress.loaded / progress.total) * 100);
        dom.loadingText.textContent = `èª­ã¿è¾¼ã¿ä¸­... ${pct}%`;
      }
    },
    (error) => {
      console.error('GLTF load error:', error);
      showLoading(false);
      URL.revokeObjectURL(url);
      notify('èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
    }
  );
}

function disposeModel(obj) {
  obj.traverse((child) => {
    if (child.isMesh) {
      child.geometry?.dispose();
      if (child.material) {
        const mats = Array.isArray(child.material) ? child.material : [child.material];
        mats.forEach(m => {
          Object.values(m).forEach(v => { if (v instanceof THREE.Texture) v.dispose(); });
          m.dispose();
        });
      }
    }
  });
}

function showLoading(show) {
  if (show) {
    dom.loadingOverlay.classList.add('active');
    dom.loadingText.textContent = 'èª­ã¿è¾¼ã¿ä¸­...';
  } else {
    dom.loadingOverlay.classList.remove('active');
  }
}

// ===== Pointer Lock (FPS Controls) ï¼‹ Touch Look =====
function requestPointerLock() {
  if (IS_TOUCH) return; // ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹ã¯PointerLockä¸è¦
  dom.container.requestPointerLock();
}

document.addEventListener('pointerlockchange', () => {
  state.isPointerLocked = document.pointerLockElement === dom.container;
  document.body.style.cursor = state.isPointerLocked ? 'none' : 'crosshair';
});

dom.container.addEventListener('click', () => {
  if (IS_TOUCH) return;
  if (state.modelLoaded && !state.panelOpen) {
    requestPointerLock();
  }
});

document.addEventListener('mousemove', (e) => {
  if (!state.isPointerLocked) return;

  state.euler.setFromQuaternion(state.camera.quaternion);
  state.euler.y -= e.movementX * state.mouseSensitivity;
  state.euler.x -= e.movementY * state.mouseSensitivity;
  state.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, state.euler.x));
  state.camera.quaternion.setFromEuler(state.euler);
});

// ===== Touch Look (å³åŠåˆ†ã‚¹ãƒ¯ã‚¤ãƒ—ã§ã‚«ãƒ¡ãƒ©å›è»¢) =====
const touchLook = {
  active: false,
  id: null,
  lastX: 0,
  lastY: 0,
};
const TOUCH_SENSITIVITY = 0.004;

function initTouchLook() {
  if (!IS_TOUCH) return;

  const zone = document.getElementById('touch-look-zone');
  zone.style.display = 'block';
  zone.style.touchAction = 'none';

  zone.addEventListener('touchstart', (e) => {
    if (state.panelOpen || !state.modelLoaded) return;
    const t = e.changedTouches[0];
    touchLook.active = true;
    touchLook.id = t.identifier;
    touchLook.lastX = t.clientX;
    touchLook.lastY = t.clientY;
    e.preventDefault();
  }, { passive: false });

  zone.addEventListener('touchmove', (e) => {
    if (!touchLook.active || !state.modelLoaded) return;
    for (const t of e.changedTouches) {
      if (t.identifier !== touchLook.id) continue;
      const dx = t.clientX - touchLook.lastX;
      const dy = t.clientY - touchLook.lastY;
      touchLook.lastX = t.clientX;
      touchLook.lastY = t.clientY;

      state.euler.setFromQuaternion(state.camera.quaternion);
      state.euler.y -= dx * TOUCH_SENSITIVITY;
      state.euler.x -= dy * TOUCH_SENSITIVITY;
      state.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, state.euler.x));
      state.camera.quaternion.setFromEuler(state.euler);
    }
    e.preventDefault();
  }, { passive: false });

  zone.addEventListener('touchend', (e) => {
    for (const t of e.changedTouches) {
      if (t.identifier === touchLook.id) {
        touchLook.active = false;
        touchLook.id = null;
      }
    }
  });
}

// ===== Touch Vertical Buttons =====
function initTouchVerticalBtns() {
  if (!IS_TOUCH) return;
  const container = document.getElementById('touch-vertical-btns');
  container.style.display = 'flex';

  const btnUp = document.getElementById('btn-touch-up');
  const btnDown = document.getElementById('btn-touch-down');

  btnUp.addEventListener('touchstart', () => { state.keys['Space'] = true; }, { passive: true });
  btnUp.addEventListener('touchend', () => { state.keys['Space'] = false; });
  btnDown.addEventListener('touchstart', () => { state.keys['Space'] = true; state.keys['ShiftLeft'] = true; }, { passive: true });
  btnDown.addEventListener('touchend', () => { state.keys['Space'] = false; state.keys['ShiftLeft'] = false; });
}

// ===== Touch Hint =====
function showTouchHint() {
  if (!IS_TOUCH) return;
  const hint = document.getElementById('touch-hint');
  hint.classList.remove('hidden');
  setTimeout(() => hint.classList.add('hidden'), 4000);
}


// ===== Keyboard =====
document.addEventListener('keydown', (e) => {
  state.keys[e.code] = true;

  if (e.code === 'KeyM') {
    togglePanel();
  }

  if (e.code === 'Escape' && state.panelOpen) {
    closePanel();
  }

  // Preset quick jump (æ•°å­—ã‚­ãƒ¼ 1ã€œ9)
  const ae = document.activeElement;
  const typing = ae && ['INPUT', 'TEXTAREA', 'SELECT'].includes(ae.tagName);
  if (!typing) {
    const slot = codeToPresetSlot(e.code);
    if (slot !== null && state.modelLoaded) {
      applyPresetBySlot(slot);
    }
  }


  // Prevent space scroll
  if (e.code === 'Space' && state.modelLoaded) {
    e.preventDefault();
  }
});

document.addEventListener('keyup', (e) => {
  state.keys[e.code] = false;
});

// ===== Virtual Joystick State =====
const joystickInput = { x: 0, y: 0 }; // x: å·¦å³, y: å‰å¾Œï¼ˆ-1ã€œ1ï¼‰

function initJoystick() {
  if (!IS_TOUCH) return;
  if (typeof nipplejs === 'undefined') {
    console.warn('nipplejs not loaded, joystick disabled');
    return;
  }

  const zone = document.getElementById('joystick-zone');
  zone.style.display = 'block';

  const manager = nipplejs.create({
    zone,
    mode: 'static',
    position: { left: '70px', bottom: '70px' },
    color: 'rgba(79,195,247,0.6)',
    size: 120,
  });

  manager.on('move', (_, data) => {
    if (!data.vector) return;
    joystickInput.x = data.vector.x;
    joystickInput.y = -data.vector.y; // nipple: up=+y â†’ å‰é€²=-y
  });

  manager.on('end', () => {
    joystickInput.x = 0;
    joystickInput.y = 0;
  });
}

// ===== Movement =====
const moveVec = new THREE.Vector3();
const frontVec = new THREE.Vector3();
const sideVec = new THREE.Vector3();

function updateMovement(delta) {
  if (!state.modelLoaded || state.panelOpen) return;

  const speed = state.moveSpeed * delta;
  moveVec.set(0, 0, 0);

  // Get camera direction vectors (ignore pitch for movement)
  state.camera.getWorldDirection(frontVec);
  frontVec.y = 0;
  frontVec.normalize();
  sideVec.crossVectors(frontVec, new THREE.Vector3(0, 1, 0)).normalize();

  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ï¼ˆPCï¼‰
  if (state.keys['KeyW']) moveVec.add(frontVec);
  if (state.keys['KeyS']) moveVec.sub(frontVec);
  if (state.keys['KeyA']) moveVec.sub(sideVec);
  if (state.keys['KeyD']) moveVec.add(sideVec);

  // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ï¼ˆã‚¿ãƒƒãƒï¼‰
  if (Math.abs(joystickInput.y) > 0.1) {
    moveVec.addScaledVector(frontVec, joystickInput.y);
  }
  if (Math.abs(joystickInput.x) > 0.1) {
    moveVec.addScaledVector(sideVec, joystickInput.x);
  }

  // Vertical movement
  if (state.keys['Space'] && state.keys['ShiftLeft']) {
    moveVec.y -= 1;
  } else if (state.keys['Space']) {
    moveVec.y += 1;
  }

  if (moveVec.length() > 0) {
    moveVec.normalize().multiplyScalar(speed);
    state.camera.position.add(moveVec);
  }
}

// ===== Camera Presets =====
function normalizePresetSlot(v) {
  const n = parseInt(v, 10);
  return Number.isFinite(n) && n >= 1 && n <= 9 ? n : null;
}

function normalizeAndDeduplicateSlots() {
  const used = new Set();
  state.presets.forEach((p) => {
    const s = normalizePresetSlot(p.slot);
    if (s === null || used.has(s)) {
      p.slot = null;
    } else {
      p.slot = s;
      used.add(s);
    }
  });
}

function savePreset(name, slotValue) {
  if (!name.trim()) return;

  const slot = normalizePresetSlot(slotValue);

  // åŒã˜ç•ªå·ãŒæ—¢ã«ä½¿ã‚ã‚Œã¦ã„ãŸã‚‰è§£é™¤
  if (slot !== null) {
    state.presets.forEach((p) => {
      if (p.slot === slot) p.slot = null;
    });
  }

  const preset = {
    name: name.trim(),
    slot,
    fov: (state.camera && state.camera.isPerspectiveCamera) ? parseFloat(state.camera.fov.toFixed(2)) : undefined,
    position: {
      x: parseFloat(state.camera.position.x.toFixed(4)),
      y: parseFloat(state.camera.position.y.toFixed(4)),
      z: parseFloat(state.camera.position.z.toFixed(4)),
    },
    rotation: {
      x: parseFloat(state.euler.x.toFixed(4)),
      y: parseFloat(state.euler.y.toFixed(4)),
      z: parseFloat(state.euler.z.toFixed(4)),
    },
    lighting: {
      exposure: state.renderer.toneMappingExposure,
      ambient: state.lights.ambient.intensity,
      directional: state.lights.directional.intensity,
      hemisphere: state.lights.hemisphere.intensity,
      lightPosition: {
        x: state.lights.directional.position.x,
        y: state.lights.directional.position.y,
        z: state.lights.directional.position.z,
      },
      envIntensity: state.envIntensity,
      bgIntensity: state.bgIntensity,
    },
    spotlights: getSpotlightsData(),
    postprocess: getPostprocessData(),
    matcaps: getMatcapData(),
    metalness: getMetalnessData(),
  };

  state.presets.push(preset);
  renderPresetList();
  schedulePresetAutoSave();
  dom.presetNameInput.value = '';
  if (dom.presetSlotInput) dom.presetSlotInput.value = '';
  notify(`ãƒ—ãƒªã‚»ãƒƒãƒˆã€Œ${preset.name}ã€ã‚’ä¿å­˜ã—ã¾ã—ãŸ`);
}

function deletePreset(index) {
  state.presets.splice(index, 1);
  renderPresetList();
  schedulePresetAutoSave();
}

function applyCameraPreset(preset) {
  state.camera.position.set(preset.position.x, preset.position.y, preset.position.z);
  state.euler.set(preset.rotation.x, preset.rotation.y, preset.rotation.z, 'YXZ');
  state.camera.quaternion.setFromEuler(state.euler);

  // Apply FOV (if present)
  if (preset.fov !== undefined && preset.fov !== null) {
    if (!state.camera?.isPerspectiveCamera) {
      // é€è¦–æŠ•å½±ã«æˆ»ã™ï¼ˆå¿…è¦æ™‚ï¼‰
      state.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 2000);
      syncPostprocessingCamera();
      // ä½ç½®ãƒ»å‘ãã¯ç›´ä¸‹ã§å†é©ç”¨ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯è§¦ã‚‰ãªã„
      state.camera.position.set(preset.position.x, preset.position.y, preset.position.z);
      state.camera.quaternion.setFromEuler(state.euler);
    }
    const f = Math.max(1, Math.min(179, Number(preset.fov)));
    if (Number.isFinite(f)) {
      state.camera.fov = f;
      state.camera.updateProjectionMatrix();
    }
  }

  // Apply lighting if present
  if (preset.lighting) {
    const l = preset.lighting;
    state.renderer.toneMappingExposure = l.exposure;
    state.lights.ambient.intensity = l.ambient;
    state.lights.directional.intensity = l.directional;
    state.lights.hemisphere.intensity = l.hemisphere;

    if (l.lightPosition) {
      state.lights.directional.position.set(l.lightPosition.x, l.lightPosition.y, l.lightPosition.z);
    }

    // Sync sliders
    syncSlider('slider-exposure', 'val-exposure', l.exposure, 4);
    syncSlider('slider-ambient', 'val-ambient', l.ambient);
    syncSlider('slider-directional', 'val-directional', l.directional);
    syncSlider('slider-hemisphere', 'val-hemisphere', l.hemisphere);
    if (l.lightPosition) {
      syncSlider('slider-light-x', 'val-light-x', l.lightPosition.x);
      syncSlider('slider-light-y', 'val-light-y', l.lightPosition.y);
      syncSlider('slider-light-z', 'val-light-z', l.lightPosition.z);
    }

    // HDRåå°„/èƒŒæ™¯
    if (l.envIntensity !== undefined) {
      state.envIntensity = l.envIntensity;
      updateEnvIntensity();
      syncSlider('slider-env-intensity', 'val-env-intensity', l.envIntensity, 2);
    }
    if (l.bgIntensity !== undefined) {
      state.bgIntensity = l.bgIntensity;
      if (l.bgIntensity <= 0.001) {
        state.scene.background = null;
      } else if (state.envMap) {
        state.scene.background = state.envMap;
        state.scene.backgroundIntensity = l.bgIntensity;
      }
      syncSlider('slider-bg-intensity', 'val-bg-intensity', l.bgIntensity, 0);
    }
  }

  // envåå°„å¼·åº¦ã‚’é©ç”¨
  updateEnvIntensity();

  // Restore spotlights
  if (preset.spotlights) {
    loadSpotlightsData(preset.spotlights);
  }

  // Restore postprocess
  if (preset.postprocess) {
    applyPostprocessData(preset.postprocess);
  }

  // Restore matcaps
  if (preset.matcaps && typeof preset.matcaps === 'object') {
    removeAllMatcaps();
    reapplyMatcapAssignments(preset.matcaps);
  }

  // Restore metalness
  if (preset.metalness && typeof preset.metalness === 'object') {
    removeAllMetalness();
    for (const [matName, val] of Object.entries(preset.metalness)) {
      applyMetalnessToMaterial(matName, val);
    }
  }

  updateFovUI();
}

function syncSlider(sliderId, valId, value, decimals) {
  const s = document.getElementById(sliderId);
  const v = document.getElementById(valId);
  if (!s || !v) return;

  s.value = value;
  const num = (typeof value === 'number') ? value : parseFloat(value);

  if (decimals !== undefined) {
    v.textContent = formatTrim(num, decimals);
  } else {
    v.textContent = String(value);
  }
}

function updateFovUI() {
  const sliderFov = document.getElementById('slider-fov');
  const valFov = document.getElementById('val-fov');
  if (!sliderFov || !valFov) return;

  if (state.camera && state.camera.isPerspectiveCamera) {
    sliderFov.disabled = false;
    const f = Number(state.camera.fov) || 70;
    sliderFov.value = f;
    valFov.textContent = String(Math.round(f));
  } else {
    sliderFov.disabled = true;
    valFov.textContent = 'â€”';
  }
}



// ===== Postprocess Preset Helpers =====
function formatTrim(v, decimals) {
  return v.toFixed(decimals).replace(/0+$/, '').replace(/\.$/, '');
}

function getPostprocessData() {
  const bloomStrength = state.post?.bloomPass ? state.post.bloomPass.strength : parseFloat(document.getElementById('slider-bloom-strength')?.value ?? 0);
  const bloomRadius = state.post?.bloomPass ? state.post.bloomPass.radius : parseFloat(document.getElementById('slider-bloom-radius')?.value ?? 0);
  const bloomThreshold = state.post?.bloomPass ? state.post.bloomPass.threshold : parseFloat(document.getElementById('slider-bloom-threshold')?.value ?? 0);
  const vignetteOffset = state.post?.vignettePass ? state.post.vignettePass.uniforms['offset'].value : parseFloat(document.getElementById('slider-vignette-offset')?.value ?? 0);
  const vignetteDarkness = state.post?.vignettePass ? state.post.vignettePass.uniforms['darkness'].value : parseFloat(document.getElementById('slider-vignette-darkness')?.value ?? 0);

  const DOF_APERTURE_SCALE = 0.00008;
  const dofFocus = state.post?.dofPass ? state.post.dofPass.materialBokeh.uniforms['focus'].value : parseFloat(document.getElementById('slider-dof-focus')?.value ?? 10);
  const dofAperture = state.post?.dofPass ? state.post.dofPass.materialBokeh.uniforms['aperture'].value : (parseFloat(document.getElementById('slider-dof-strength')?.value ?? 0.25) * DOF_APERTURE_SCALE);
  const dofMaxBlur = state.post?.dofPass ? state.post.dofPass.materialBokeh.uniforms['maxblur'].value : parseFloat(document.getElementById('slider-dof-maxblur')?.value ?? 0.01);

  return {
    enabled: !!state.postEnabled,
    dof: {
      enabled: !!state.post?.dofPass?.enabled,
      focus: dofFocus,
      strength: (dofAperture / DOF_APERTURE_SCALE),
      maxblur: dofMaxBlur,
    },
    bloom: {
      enabled: !!state.post?.bloomPass?.enabled,
      strength: bloomStrength,
      radius: bloomRadius,
      threshold: bloomThreshold,
    },
    vignette: {
      enabled: !!state.post?.vignettePass?.enabled,
      offset: vignetteOffset,
      darkness: vignetteDarkness,
    },
    fxaa: {
      enabled: !!state.post?.fxaaPass?.enabled,
    },
  };
}


function applyPostprocessData(pp) {
  if (!pp) return;
  if (!state.composer || !state.post) initPostprocessing();

  const chkEnable = document.getElementById('chk-post-enable');  const chkBloom = document.getElementById('chk-post-bloom');
  const chkDOF = document.getElementById('chk-post-dof');
  const chkVignette = document.getElementById('chk-post-vignette');
  const chkFXAA = document.getElementById('chk-post-fxaa');  const sliderBloomStrength = document.getElementById('slider-bloom-strength');
  const valBloomStrength = document.getElementById('val-bloom-strength');
  const sliderBloomRadius = document.getElementById('slider-bloom-radius');
  const valBloomRadius = document.getElementById('val-bloom-radius');
  const sliderBloomThreshold = document.getElementById('slider-bloom-threshold');
  const valBloomThreshold = document.getElementById('val-bloom-threshold');

  const sliderDofFocus = document.getElementById('slider-dof-focus');
  const valDofFocus = document.getElementById('val-dof-focus');
  const sliderDofStrength = document.getElementById('slider-dof-strength');
  const valDofStrength = document.getElementById('val-dof-strength');
  const sliderDofMaxBlur = document.getElementById('slider-dof-maxblur');
  const valDofMaxBlur = document.getElementById('val-dof-maxblur');

  const sliderVignetteOffset = document.getElementById('slider-vignette-offset');
  const valVignetteOffset = document.getElementById('val-vignette-offset');
  const sliderVignetteDarkness = document.getElementById('slider-vignette-darkness');
  const valVignetteDarkness = document.getElementById('val-vignette-darkness');

  // Enabled
  if (typeof pp.enabled === 'boolean') {
    state.postEnabled = pp.enabled;
    if (chkEnable) chkEnable.checked = pp.enabled;
  }

  // Bloom
  if (pp.bloom) {
    if (typeof pp.bloom.enabled === 'boolean') {
      if (chkBloom) chkBloom.checked = pp.bloom.enabled;
      if (state.post?.bloomPass) state.post.bloomPass.enabled = pp.bloom.enabled;
    }
    if (typeof pp.bloom.strength === 'number' && isFinite(pp.bloom.strength)) {
      const v = pp.bloom.strength;
      if (sliderBloomStrength) sliderBloomStrength.value = v;
      if (valBloomStrength) valBloomStrength.textContent = formatTrim(v, 3);
      if (state.post?.bloomPass) state.post.bloomPass.strength = v;
    }
    if (typeof pp.bloom.radius === 'number' && isFinite(pp.bloom.radius)) {
      const v = pp.bloom.radius;
      if (sliderBloomRadius) sliderBloomRadius.value = v;
      if (valBloomRadius) valBloomRadius.textContent = formatTrim(v, 3);
      if (state.post?.bloomPass) state.post.bloomPass.radius = v;
    }
    if (typeof pp.bloom.threshold === 'number' && isFinite(pp.bloom.threshold)) {
      const v = pp.bloom.threshold;
      if (sliderBloomThreshold) sliderBloomThreshold.value = v;
      if (valBloomThreshold) valBloomThreshold.textContent = v.toFixed(2);
      if (state.post?.bloomPass) state.post.bloomPass.threshold = v;
    }
  }

  // DOF
  if (pp.dof) {
    const DOF_APERTURE_SCALE = 0.00008;
    if (typeof pp.dof.enabled === 'boolean') {
      if (chkDOF) chkDOF.checked = pp.dof.enabled;
      if (state.post?.dofPass) state.post.dofPass.enabled = pp.dof.enabled;
    }
    if (typeof pp.dof.focus === 'number' && isFinite(pp.dof.focus)) {
      const v = pp.dof.focus;
      if (sliderDofFocus) sliderDofFocus.value = v;
      if (valDofFocus) valDofFocus.textContent = formatTrim(v, 2);
      if (state.post?.dofPass) state.post.dofPass.materialBokeh.uniforms['focus'].value = v;
    }
    if (typeof pp.dof.strength === 'number' && isFinite(pp.dof.strength)) {
      const s = Math.max(0, pp.dof.strength);
      const a = s * DOF_APERTURE_SCALE;
      if (sliderDofStrength) sliderDofStrength.value = s;
      if (valDofStrength) valDofStrength.textContent = formatTrim(s, 2);
      if (state.post?.dofPass) state.post.dofPass.materialBokeh.uniforms['aperture'].value = a;
    }
    if (typeof pp.dof.maxblur === 'number' && isFinite(pp.dof.maxblur)) {
      const v = pp.dof.maxblur;
      if (sliderDofMaxBlur) sliderDofMaxBlur.value = v;
      if (valDofMaxBlur) valDofMaxBlur.textContent = formatTrim(v, 3);
      if (state.post?.dofPass) state.post.dofPass.materialBokeh.uniforms['maxblur'].value = v;
    }
  }

  // Vignette
  if (pp.vignette) {
    if (typeof pp.vignette.enabled === 'boolean') {
      if (chkVignette) chkVignette.checked = pp.vignette.enabled;
      if (state.post?.vignettePass) state.post.vignettePass.enabled = pp.vignette.enabled;
    }
    if (typeof pp.vignette.offset === 'number' && isFinite(pp.vignette.offset)) {
      const v = pp.vignette.offset;
      if (sliderVignetteOffset) sliderVignetteOffset.value = v;
      if (valVignetteOffset) valVignetteOffset.textContent = formatTrim(v, 2);
      if (state.post?.vignettePass) state.post.vignettePass.uniforms['offset'].value = v;
    }
    if (typeof pp.vignette.darkness === 'number' && isFinite(pp.vignette.darkness)) {
      const v = pp.vignette.darkness;
      if (sliderVignetteDarkness) sliderVignetteDarkness.value = v;
      if (valVignetteDarkness) valVignetteDarkness.textContent = formatTrim(v, 3);
      if (state.post?.vignettePass) state.post.vignettePass.uniforms['darkness'].value = v;
    }
  }

  // FXAA
  if (pp.fxaa) {
    if (typeof pp.fxaa.enabled === 'boolean') {
      if (chkFXAA) chkFXAA.checked = pp.fxaa.enabled;
      if (state.post?.fxaaPass) state.post.fxaaPass.enabled = pp.fxaa.enabled;
    }
  }
}


// ===== Spotlights (Window Light) =====
function addSpotlight() {
  const dir = new THREE.Vector3();
  state.camera.getWorldDirection(dir);

  const pos = state.camera.position.clone();
  const targetPos = pos.clone().add(dir.multiplyScalar(5));

  const light = new THREE.SpotLight(0xfff8e8, 5000, 30, Math.PI / 4, 0.3, 1);
  light.position.copy(pos);
  light.target.position.copy(targetPos);
  light.castShadow = true;
  light.shadow.mapSize.width = 1024;
  light.shadow.mapSize.height = 1024;
  light.shadow.bias = 0;
  light.shadow.normalBias = 0.05;
  state.scene.add(light);
  state.scene.add(light.target);

  const helper = new THREE.SpotLightHelper(light);
  if (state.showHelpers) state.scene.add(helper);

  const idx = state.spotlights.length;
  const name = `ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆ ${idx + 1}`;

  state.spotlights.push({ light, helper, name, targetPos });
  renderSpotlightList();
  selectSpotlight(idx);
  notify(`ã€Œ${name}ã€ã‚’è¿½åŠ ã—ã¾ã—ãŸ`);
}

function removeSpotlight(index) {
  const sp = state.spotlights[index];
  state.scene.remove(sp.light);
  state.scene.remove(sp.light.target);
  state.scene.remove(sp.helper);
  sp.light.dispose();
  sp.helper.dispose();
  state.spotlights.splice(index, 1);

  if (state.selectedSpotlight === index) {
    state.selectedSpotlight = -1;
    document.getElementById('spotlight-edit').style.display = 'none';
  } else if (state.selectedSpotlight > index) {
    state.selectedSpotlight--;
  }
  renderSpotlightList();
}

function selectSpotlight(index) {
  state.selectedSpotlight = index;
  const sp = state.spotlights[index];
  const editPanel = document.getElementById('spotlight-edit');
  editPanel.style.display = 'block';
  document.getElementById('spotlight-edit-name').textContent = sp.name;

  syncSlider('slider-sp-intensity', 'val-sp-intensity', sp.light.intensity);
  syncSlider('slider-sp-angle', 'val-sp-angle', Math.round(sp.light.angle * 180 / Math.PI));
  document.getElementById('val-sp-angle').textContent = Math.round(sp.light.angle * 180 / Math.PI) + 'Â°';
  syncSlider('slider-sp-penumbra', 'val-sp-penumbra', sp.light.penumbra, 2);
  syncSlider('slider-sp-distance', 'val-sp-distance', sp.light.distance);

  // Highlight selected in list
  document.querySelectorAll('#spotlight-list .preset-item').forEach((el, i) => {
    el.style.borderColor = i === index ? 'rgba(79, 195, 247, 0.5)' : '';
  });
}

function renderSpotlightList() {
  const list = document.getElementById('spotlight-list');
  if (state.spotlights.length === 0) {
    list.innerHTML = '<div class="empty-state">ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆãªã—</div>';
    document.getElementById('spotlight-edit').style.display = 'none';
    return;
  }

  list.innerHTML = '';
  state.spotlights.forEach((sp, i) => {
    const item = document.createElement('div');
    item.className = 'preset-item';
    item.innerHTML = `
      <span class="preset-name">${escapeHtml(sp.name)}</span>
      <span class="preset-coords">${sp.light.intensity}</span>
      <button class="preset-delete" title="å‰Šé™¤">
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
          <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
        </svg>
      </button>
    `;

    item.addEventListener('click', (e) => {
      if (e.target.closest('.preset-delete')) return;
      selectSpotlight(i);
    });

    item.querySelector('.preset-delete').addEventListener('click', (e) => {
      e.stopPropagation();
      removeSpotlight(i);
    });

    list.appendChild(item);
  });
}

function getSpotlightsData() {
  return state.spotlights.map(sp => ({
    name: sp.name,
    position: { x: sp.light.position.x, y: sp.light.position.y, z: sp.light.position.z },
    target: { x: sp.light.target.position.x, y: sp.light.target.position.y, z: sp.light.target.position.z },
    intensity: sp.light.intensity,
    angle: sp.light.angle,
    penumbra: sp.light.penumbra,
    distance: sp.light.distance,
  }));
}

function loadSpotlightsData(dataArray) {
  // Remove existing
  while (state.spotlights.length > 0) removeSpotlight(0);

  if (!dataArray || !Array.isArray(dataArray)) return;

  dataArray.forEach(d => {
    const light = new THREE.SpotLight(0xfff8e8, d.intensity, d.distance, d.angle, d.penumbra, 1);
    light.position.set(d.position.x, d.position.y, d.position.z);
    light.target.position.set(d.target.x, d.target.y, d.target.z);
    light.castShadow = true;
    light.shadow.mapSize.width = 1024;
    light.shadow.mapSize.height = 1024;
    light.shadow.bias = 0;
    light.shadow.normalBias = 0.05;
    state.scene.add(light);
    state.scene.add(light.target);

    const helper = new THREE.SpotLightHelper(light);
    if (state.showHelpers) state.scene.add(helper);

    state.spotlights.push({
      light, helper,
      name: d.name || `ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆ ${state.spotlights.length + 1}`,
      targetPos: light.target.position.clone(),
    });
  });
  renderSpotlightList();
}

function toggleSpotlightHelpers(show) {
  state.showHelpers = show;
  state.spotlights.forEach(sp => {
    if (show) {
      if (!sp.helper.parent) state.scene.add(sp.helper);
    } else {
      state.scene.remove(sp.helper);
    }
  });
}


function renderSlotOptions(selectedSlot) {
  const sel = selectedSlot ? String(selectedSlot) : '';
  let html = '<option value="">â€”</option>';
  for (let n = 1; n <= 9; n++) {
    const s = String(n);
    html += `<option value="${s}" ${sel === s ? 'selected' : ''}>${s}</option>`;
  }
  return html;
}

function setPresetSlot(index, slotValue) {
  const slot = normalizePresetSlot(slotValue);
  // é‡è¤‡ã™ã‚‹ç•ªå·ãŒã‚ã‚Œã°è§£é™¤ï¼ˆæœ€å¾Œã«é¸ã‚“ã ã‚‚ã®ã‚’å„ªå…ˆï¼‰
  if (slot !== null) {
    state.presets.forEach((p, i) => {
      if (i !== index && p.slot === slot) p.slot = null;
    });
  }
  state.presets[index].slot = slot;
  renderPresetList();
  schedulePresetAutoSave();
}

function getPresetBySlot(slot) {
  return state.presets.find((p) => p.slot === slot) || null;
}

function applyPresetBySlot(slot) {
  const preset = getPresetBySlot(slot);
  if (!preset) {
    notify(`æ•°å­—${slot}ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒ—ãƒªã‚»ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“`);
    return false;
  }
  applyCameraPreset(preset);
  if (state.panelOpen) closePanel();
  notify(`ã€Œ${preset.name}ã€ã«ç§»å‹•ã—ã¾ã—ãŸï¼ˆ${slot}ï¼‰`);
  return true;
}

function codeToPresetSlot(code) {
  if (code.startsWith('Digit')) {
    const n = parseInt(code.slice(5), 10);
    return (n >= 1 && n <= 9) ? n : null;
  }
  if (code.startsWith('Numpad')) {
    const n = parseInt(code.slice(6), 10);
    return (n >= 1 && n <= 9) ? n : null;
  }
  return null;
}

function renderPresetList() {
  if (state.presets.length === 0) {
    dom.presetList.innerHTML = '<div class="empty-state">ãƒ—ãƒªã‚»ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“</div>';
    return;
  }

  dom.presetList.innerHTML = '';
  state.presets.forEach((preset, i) => {
    const item = document.createElement('div');
    item.className = 'preset-item';
    item.innerHTML = `
      <span class="preset-name">${escapeHtml(preset.name)}</span>
      <span class="preset-coords">${preset.position.x.toFixed(1)}, ${preset.position.y.toFixed(1)}, ${preset.position.z.toFixed(1)}</span>
      <select class="preset-slot-select" data-index="${i}" title="æ•°å­—ã‚­ãƒ¼å‰²ã‚Šå½“ã¦">
        ${renderSlotOptions(preset.slot)}
      </select>
      <button class="preset-delete" data-index="${i}" title="å‰Šé™¤">
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
          <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
        </svg>
      </button>
    `;

    item.addEventListener('click', (e) => {
      if (e.target.closest('.preset-delete')) return;
      if (e.target.closest('.preset-slot-select')) return;
      applyCameraPreset(preset);
      closePanel();
      notify(`ã€Œ${preset.name}ã€ã«ç§»å‹•ã—ã¾ã—ãŸ`);
    });

    const slotSelect = item.querySelector('.preset-slot-select');
    slotSelect.addEventListener('click', (e) => e.stopPropagation());
    slotSelect.addEventListener('change', (e) => {
      e.stopPropagation();
      setPresetSlot(i, e.target.value);
    });

    item.querySelector('.preset-delete').addEventListener('click', (e) => {
      e.stopPropagation();
      deletePreset(i);
    });

    dom.presetList.appendChild(item);
  });
}



// ===== Preset persistence (localStorage) =====
const PRESET_FILENAME = 'camera_presets.json';
const PRESET_LS_KEY = 'gltf_viewer_presets';
let presetAutoSaveTimer = null;

function fallbackDownloadPresets() {
  if (state.presets.length === 0) {
    notify('æ›¸ãå‡ºã™ãƒ—ãƒªã‚»ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“');
    return;
  }
  const data = JSON.stringify({ presets: state.presets }, null, 2);
  const blob = new Blob([data], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = PRESET_FILENAME;
  a.click();
  URL.revokeObjectURL(url);
}

async function savePresetsToServer({ silent = false } = {}) {
  try {
    localStorage.setItem(PRESET_LS_KEY, JSON.stringify({ presets: state.presets }));
    if (!silent) notify(`ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’ä¿å­˜ã—ã¾ã—ãŸ`);
    return { ok: true };
  } catch (e) {
    if (!silent) {
      fallbackDownloadPresets();
      notify('ä¿å­˜ã«å¤±æ•—ã—ãŸãŸã‚ã€ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã§æ›¸ãå‡ºã—ã¾ã—ãŸ');
    }
    return { ok: false };
  }
}

function schedulePresetAutoSave() {
  clearTimeout(presetAutoSaveTimer);
  presetAutoSaveTimer = setTimeout(() => {
    savePresetsToServer({ silent: true });
  }, 500);
}

async function autoLoadPresets() {
  try {
    const raw = localStorage.getItem(PRESET_LS_KEY);
    if (!raw) return;
    const data = JSON.parse(raw);
    if (data && Array.isArray(data.presets)) {
      state.presets = data.presets;
      normalizeAndDeduplicateSlots();
      renderPresetList();
      if (state.presets.length > 0) {
        notify(`${state.presets.length}ä»¶ã®ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
      }
    }
  } catch (e) {
    console.log('Preset auto-load skipped:', e.message);
  }
}

async function exportPresets() {
  if (state.presets.length === 0) {
    notify('æ›¸ãå‡ºã™ãƒ—ãƒªã‚»ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“');
    return;
  }
  await savePresetsToServer({ silent: false });
}

function importPresets(file) {
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const data = JSON.parse(e.target.result);
      if (data.presets && Array.isArray(data.presets)) {
        state.presets = data.presets;
        normalizeAndDeduplicateSlots();
        renderPresetList();
        schedulePresetAutoSave();

        // If model loaded, apply first preset
        if (state.modelLoaded && state.presets.length > 0) {
          applyCameraPreset(state.presets[0]);
        }

        notify(`${state.presets.length}ä»¶ã®ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
      } else {
        notify('ç„¡åŠ¹ãªJSONãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ã™');
      }
    } catch (err) {
      notify('JSONã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  };
  reader.readAsText(file);
}

// ===== Panel =====
function togglePanel() {
  if (state.panelOpen) closePanel();
  else openPanel();
}

function openPanel() {
  state.panelOpen = true;
  dom.sidePanel.classList.add('open');
  if (document.pointerLockElement) document.exitPointerLock();
}

function closePanel() {
  state.panelOpen = false;
  dom.sidePanel.classList.remove('open');
}

// ===== Drag & Drop =====
// ===== File Input Events =====
function initFileInputs() {
  const hdrInput = document.getElementById('hdr-input');
  dom.gltfInput.addEventListener('change', (e) => {
    if (e.target.files[0]) loadGLTF(e.target.files[0]);
    e.target.value = '';
  });

  dom.gltfInputWelcome.addEventListener('change', (e) => {
    if (e.target.files[0]) loadGLTF(e.target.files[0]);
    e.target.value = '';
  });

  dom.jsonInput.addEventListener('change', (e) => {
    if (e.target.files[0]) importPresets(e.target.files[0]);
    e.target.value = '';
  });

  if (hdrInput) {
  hdrInput.addEventListener('change', (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    const loader = new RGBELoader();
    loader.setDataType(THREE.HalfFloatType);
    loader.load(
      url,
      (hdrEquirect) => {
        URL.revokeObjectURL(url);
        setEnvironmentFromEquirect(hdrEquirect);
      },
      undefined,
      (err) => {
        URL.revokeObjectURL(url);
        console.warn('HDR load error:', err);
        notify('HDR ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    );
    // åŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å†é¸æŠã§ãã‚‹ã‚ˆã†ã«
    e.target.value = '';
  });
  }

  dom.btnSavePreset.addEventListener('click', () => savePreset(dom.presetNameInput.value, dom.presetSlotInput?.value));
  dom.presetNameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') savePreset(dom.presetNameInput.value, dom.presetSlotInput?.value);
    e.stopPropagation(); // Don't trigger WASD
  });

  dom.presetSlotInput?.addEventListener('keydown', (e) => {
    e.stopPropagation();
  });

  dom.btnExportPresets.addEventListener('click', exportPresets);
  dom.menuToggle.addEventListener('click', togglePanel);
  dom.panelClose.addEventListener('click', closePanel);

  // Camera FOV
  const sliderFov = document.getElementById('slider-fov');
  const valFov = document.getElementById('val-fov');
  if (sliderFov && valFov) {
    updateFovUI();
    sliderFov.addEventListener('input', (e) => {
      if (!state.camera?.isPerspectiveCamera) {
        updateFovUI();
        return;
      }
      const v = parseFloat(e.target.value);
      state.camera.fov = v;
      state.camera.updateProjectionMatrix();
      valFov.textContent = String(Math.round(v));
    });
  }

  // Lighting sliders
  const sliderExposure = document.getElementById('slider-exposure');
  const sliderAmbient = document.getElementById('slider-ambient');
  const sliderDirectional = document.getElementById('slider-directional');
  const sliderHemisphere = document.getElementById('slider-hemisphere');
  const sliderEnvIntensity = document.getElementById('slider-env-intensity');
  const sliderBgIntensity = document.getElementById('slider-bg-intensity');
  const valExposure = document.getElementById('val-exposure');
  const valAmbient = document.getElementById('val-ambient');
  const valDirectional = document.getElementById('val-directional');
  const valHemisphere = document.getElementById('val-hemisphere');
  const valEnvIntensity = document.getElementById('val-env-intensity');
  const valBgIntensity = document.getElementById('val-bg-intensity');

  sliderExposure.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    state.renderer.toneMappingExposure = v;
    // éœ²å‡ºãŒå¤‰ã‚ã‚‹ã¨ environmentIntensity è£œæ­£å€¤ã‚‚å¤‰ã‚ã‚‹
    updateEnvIntensity();
    valExposure.textContent = formatTrim(v, 4);
  });

  sliderEnvIntensity.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    state.envIntensity = v;
    updateEnvIntensity();
    valEnvIntensity.textContent = formatTrim(v, 2);
  });

  sliderBgIntensity.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    state.bgIntensity = v;
    if (v <= 0.001) {
      state.scene.background = null;
    } else if (state.envMap) {
      state.scene.background = state.envMap;
      state.scene.backgroundIntensity = v;
    }
    valBgIntensity.textContent = v.toFixed(0);
  });

  sliderAmbient.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    state.lights.ambient.intensity = v;
    valAmbient.textContent = v;
  });

  sliderDirectional.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    state.lights.directional.intensity = v;
    valDirectional.textContent = v;
  });

  sliderHemisphere.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    state.lights.hemisphere.intensity = v;
    valHemisphere.textContent = v;
  });

  // Light position sliders
  const sliderLX = document.getElementById('slider-light-x');
  const sliderLY = document.getElementById('slider-light-y');
  const sliderLZ = document.getElementById('slider-light-z');
  const valLX = document.getElementById('val-light-x');
  const valLY = document.getElementById('val-light-y');
  const valLZ = document.getElementById('val-light-z');

  sliderLX.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    state.lights.directional.position.x = v;
    valLX.textContent = v;
  });

  sliderLY.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    state.lights.directional.position.y = v;
    valLY.textContent = v;
  });

  sliderLZ.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    state.lights.directional.position.z = v;
    valLZ.textContent = v;
  });

  // Collapsible sections
  document.getElementById('toggle-lighting').addEventListener('click', () => {
    document.getElementById('toggle-lighting').classList.toggle('open');
    document.getElementById('lighting-content').classList.toggle('open');
  });
  document.getElementById('toggle-lightpos').addEventListener('click', () => {
    document.getElementById('toggle-lightpos').classList.toggle('open');
    document.getElementById('lightpos-content').classList.toggle('open');
  });
  document.getElementById('toggle-postfx').addEventListener('click', () => {
    document.getElementById('toggle-postfx').classList.toggle('open');
    document.getElementById('postfx-content').classList.toggle('open');
  });

  document.getElementById('toggle-spotlight').addEventListener('click', () => {
    document.getElementById('toggle-spotlight').classList.toggle('open');
    document.getElementById('spotlight-content').classList.toggle('open');
  });

  document.getElementById('toggle-model').addEventListener('click', () => {
    document.getElementById('toggle-model').classList.toggle('open');
    document.getElementById('model-content').classList.toggle('open');
  });

  document.getElementById('toggle-hdr').addEventListener('click', () => {
    document.getElementById('toggle-hdr').classList.toggle('open');
    document.getElementById('hdr-content').classList.toggle('open');
  });

  document.getElementById('toggle-matcap').addEventListener('click', () => {
    document.getElementById('toggle-matcap').classList.toggle('open');
    document.getElementById('matcap-content').classList.toggle('open');
  });


  // Postprocess controls
  const chkPostEnable = document.getElementById('chk-post-enable');  const chkPostBloom = document.getElementById('chk-post-bloom');
  const chkPostDOF = document.getElementById('chk-post-dof');
  const chkPostVignette = document.getElementById('chk-post-vignette');
  const chkPostFXAA = document.getElementById('chk-post-fxaa');  const sliderBloomStrength = document.getElementById('slider-bloom-strength');
  const valBloomStrength = document.getElementById('val-bloom-strength');
  const sliderBloomRadius = document.getElementById('slider-bloom-radius');
  const valBloomRadius = document.getElementById('val-bloom-radius');
  const sliderBloomThreshold = document.getElementById('slider-bloom-threshold');
  const valBloomThreshold = document.getElementById('val-bloom-threshold');

  const sliderDofFocus = document.getElementById('slider-dof-focus');
  const valDofFocus = document.getElementById('val-dof-focus');
  const sliderDofStrength = document.getElementById('slider-dof-strength');
  const valDofStrength = document.getElementById('val-dof-strength');
  const sliderDofMaxBlur = document.getElementById('slider-dof-maxblur');
  const valDofMaxBlur = document.getElementById('val-dof-maxblur');

  const sliderVignetteOffset = document.getElementById('slider-vignette-offset');
  const valVignetteOffset = document.getElementById('val-vignette-offset');
  const sliderVignetteDarkness = document.getElementById('slider-vignette-darkness');
  const valVignetteDarkness = document.getElementById('val-vignette-darkness');

  // initial apply
  state.postEnabled = chkPostEnable.checked;
  if (state.post?.bloomPass) state.post.bloomPass.enabled = chkPostBloom.checked;
  if (state.post?.dofPass) state.post.dofPass.enabled = chkPostDOF.checked;
  if (state.post?.vignettePass) state.post.vignettePass.enabled = chkPostVignette.checked;
  if (state.post?.fxaaPass) state.post.fxaaPass.enabled = chkPostFXAA.checked;

  // DOF åˆæœŸå€¤ï¼ˆã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼â†’uniformåæ˜ ï¼‰
  const DOF_APERTURE_SCALE = 0.00008;
  if (state.post?.dofPass) {
    const f = parseFloat(sliderDofFocus?.value ?? 10);
    const s = parseFloat(sliderDofStrength?.value ?? 0.25);
    const mb = parseFloat(sliderDofMaxBlur?.value ?? 0.01);
    state.post.dofPass.materialBokeh.uniforms['focus'].value = f;
    state.post.dofPass.materialBokeh.uniforms['aperture'].value = s * DOF_APERTURE_SCALE;
    state.post.dofPass.materialBokeh.uniforms['maxblur'].value = mb;
  }

  chkPostEnable.addEventListener('change', () => {
    state.postEnabled = chkPostEnable.checked;
  });  chkPostBloom.addEventListener('change', () => {
    if (state.post?.bloomPass) state.post.bloomPass.enabled = chkPostBloom.checked;
  });
  chkPostDOF.addEventListener('change', () => {
    if (state.post?.dofPass) state.post.dofPass.enabled = chkPostDOF.checked;
  });
  chkPostVignette.addEventListener('change', () => {
    if (state.post?.vignettePass) state.post.vignettePass.enabled = chkPostVignette.checked;
  });
  chkPostFXAA.addEventListener('change', () => {
    if (state.post?.fxaaPass) state.post.fxaaPass.enabled = chkPostFXAA.checked;
  });    

  

  sliderBloomStrength.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    valBloomStrength.textContent = v.toFixed(3).replace(/0+$/, '').replace(/\.$/, '');
    if (state.post?.bloomPass) state.post.bloomPass.strength = v;
  });
  sliderBloomRadius.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    valBloomRadius.textContent = v.toFixed(3).replace(/0+$/, '').replace(/\.$/, '');
    if (state.post?.bloomPass) state.post.bloomPass.radius = v;
  });
  sliderBloomThreshold.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    valBloomThreshold.textContent = v.toFixed(2);
    if (state.post?.bloomPass) state.post.bloomPass.threshold = v;
  });

  // DOF
  sliderDofFocus.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    valDofFocus.textContent = v.toFixed(2).replace(/0+$/, '').replace(/\.$/, '');
    if (state.post?.dofPass) state.post.dofPass.materialBokeh.uniforms['focus'].value = v;
  });
  sliderDofStrength.addEventListener('input', (e) => {
    const s = parseFloat(e.target.value);
    valDofStrength.textContent = s.toFixed(2).replace(/0+$/, '').replace(/\.$/, '');
    if (state.post?.dofPass) state.post.dofPass.materialBokeh.uniforms['aperture'].value = s * DOF_APERTURE_SCALE;
  });
  sliderDofMaxBlur.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    valDofMaxBlur.textContent = v.toFixed(3).replace(/0+$/, '').replace(/\.$/, '');
    if (state.post?.dofPass) state.post.dofPass.materialBokeh.uniforms['maxblur'].value = v;
  });

  sliderVignetteOffset.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    valVignetteOffset.textContent = v.toFixed(2).replace(/0+$/, '').replace(/\.$/, '');
    if (state.post?.vignettePass) state.post.vignettePass.uniforms['offset'].value = v;
  });
  sliderVignetteDarkness.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    valVignetteDarkness.textContent = v.toFixed(3).replace(/0+$/, '').replace(/\.$/, '');
    if (state.post?.vignettePass) state.post.vignettePass.uniforms['darkness'].value = v;
  });



  // Spotlight controls
  document.getElementById('btn-add-spotlight').addEventListener('click', addSpotlight);

  document.getElementById('slider-sp-intensity').addEventListener('input', (e) => {
    if (state.selectedSpotlight < 0) return;
    const v = parseFloat(e.target.value);
    state.spotlights[state.selectedSpotlight].light.intensity = v;
    document.getElementById('val-sp-intensity').textContent = v;
    renderSpotlightList();
  });

  document.getElementById('slider-sp-angle').addEventListener('input', (e) => {
    if (state.selectedSpotlight < 0) return;
    const deg = parseFloat(e.target.value);
    state.spotlights[state.selectedSpotlight].light.angle = deg * Math.PI / 180;
    document.getElementById('val-sp-angle').textContent = deg + 'Â°';
    state.spotlights[state.selectedSpotlight].helper.update();
  });

  document.getElementById('slider-sp-penumbra').addEventListener('input', (e) => {
    if (state.selectedSpotlight < 0) return;
    const v = parseFloat(e.target.value);
    state.spotlights[state.selectedSpotlight].light.penumbra = v;
    document.getElementById('val-sp-penumbra').textContent = v.toFixed(2);
  });

  document.getElementById('slider-sp-distance').addEventListener('input', (e) => {
    if (state.selectedSpotlight < 0) return;
    const v = parseFloat(e.target.value);
    state.spotlights[state.selectedSpotlight].light.distance = v;
    document.getElementById('val-sp-distance').textContent = v;
    state.spotlights[state.selectedSpotlight].helper.update();
  });

  document.getElementById('chk-sp-helpers').addEventListener('change', (e) => {
    toggleSpotlightHelpers(e.target.checked);
  });
}

// ===== HUD =====
function updateHUD() {
  const now = performance.now();
  state.fpsTimes.push(now);
  while (state.fpsTimes.length > 0 && state.fpsTimes[0] <= now - 1000) {
    state.fpsTimes.shift();
  }
  state.currentFps = state.fpsTimes.length;

  dom.hudX.textContent = state.camera.position.x.toFixed(2);
  dom.hudY.textContent = state.camera.position.y.toFixed(2);
  dom.hudZ.textContent = state.camera.position.z.toFixed(2);
  dom.hudFps.textContent = state.currentFps;
}

// ===== Utilities =====
function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function notify(message) {
  const el = document.createElement('div');
  el.className = 'notification';
  el.textContent = message;
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 3000);
}

// ===== Render Loop =====
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();

  updateMovement(delta);
  updateHUD();

  // Update spotlight helpers
  if (state.showHelpers) {
    state.spotlights.forEach(sp => sp.helper.update());
  }

  if (state.composer && state.postEnabled) {
    state.composer.render();
  } else {
    state.renderer.render(state.scene, state.camera);
  }
}

// ===== åŒãƒ•ã‚©ãƒ«ãƒ€GLTFè‡ªå‹•æ¤œå‡ºï¼†èª­ã¿è¾¼ã¿ =====
async function autoLoadGLTF() {
  // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ ?model=xxx.glb ãŒã‚ã‚Œã°èª­ã¿è¾¼ã‚€ï¼ˆGitHub Pageså¯¾å¿œï¼‰
  const params = new URLSearchParams(location.search);
  const modelParam = params.get('model');
  if (modelParam) {
    const baseDir = location.href.substring(0, location.href.lastIndexOf('/') + 1);
    const url = new URL(modelParam, baseDir).href;
    console.log(`Loading GLTF from URL param: ${modelParam}`);
    loadGLTFFromURL(url, modelParam.split('/').pop());
    return;
  }
  console.log('No model param. Waiting for file selection.');
}


// ===== Matcap System =====
const MATCAP_API = '/api/matcaps';
const MATCAP_DIR = 'matcaps/';  // viewer.htmlã‹ã‚‰ã®ç›¸å¯¾ãƒ‘ã‚¹ï¼ˆåŒã˜ã‚·ã‚¹ãƒ†ãƒ ãƒ•ã‚©ãƒ«ãƒ€å†…ï¼‰

async function loadMatcapList() {
  const gallery = document.getElementById('matcap-gallery');
  const loading = document.getElementById('matcap-loading');

  // GitHub Pages / é™çš„ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°ã§ã¯matcap APIã¯ä½¿ãˆãªã„
  // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã§è¿½åŠ ã™ã‚‹æ–¹å¼ã®ã¿å¯¾å¿œ
  state.matcapFiles = [];

  if (loading) loading.remove();
  gallery.innerHTML = '<div class="hint">matcapsãƒ•ã‚©ãƒ«ãƒ€ã«ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“</div>';
}

function renderMatcapGallery() {
  const gallery = document.getElementById('matcap-gallery');
  gallery.innerHTML = '';

  // --- åå°„ãƒ—ãƒªã‚»ãƒƒãƒˆï¼ˆmetalnessï¼‰ ---
  const presets = [
    { label: 'åå°„\n100', metalness: 1 },
    { label: 'åå°„\n50',  metalness: 0.5 },
    { label: 'åå°„\n0',   metalness: 0 },
  ];
  for (const p of presets) {
    const el = document.createElement('div');
    el.className = 'metalness-preset';
    el.dataset.metalness = p.metalness;
    el.textContent = p.label;
    el.draggable = true;
    el.title = `åå°„ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’ ${(p.metalness * 100).toFixed(0)} ã«è¨­å®š`;
    el.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('text/metalness-preset', String(p.metalness));
      el.classList.add('dragging');
    });
    el.addEventListener('dragend', () => {
      el.classList.remove('dragging');
      hideMatcapDropIndicator();
    });
    gallery.appendChild(el);
  }

  // --- ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ ---
  if (state.matcapFiles.length > 0) {
    const sep = document.createElement('div');
    sep.style.cssText = 'width:1px;height:40px;background:rgba(255,255,255,0.1);margin:0 2px;flex-shrink:0;';
    gallery.appendChild(sep);
  }

  // --- ãƒãƒƒãƒˆã‚­ãƒ£ãƒƒãƒ— ---
  for (const file of state.matcapFiles) {
    const img = document.createElement('img');
    img.className = 'matcap-thumb';
    img.src = encodeURI(MATCAP_DIR + file);
    img.alt = file;
    img.title = file;
    img.draggable = true;
    img.dataset.matcapFile = file;

    img.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('text/matcap-file', file);
      img.classList.add('dragging');
    });
    img.addEventListener('dragend', () => {
      img.classList.remove('dragging');
      hideMatcapDropIndicator();
    });

    gallery.appendChild(img);
  }
}

// --- Matcap texture loading (cached) ---
function loadMatcapTexture(file) {
  if (state.matcapTextures[file]) {
    return Promise.resolve(state.matcapTextures[file]);
  }
  return new Promise((resolve, reject) => {
    const loader = new THREE.TextureLoader();
    loader.load(
      encodeURI(MATCAP_DIR + file),
      (tex) => {
        tex.colorSpace = THREE.SRGBColorSpace;
        state.matcapTextures[file] = tex;
        resolve(tex);
      },
      undefined,
      (err) => reject(err)
    );
  });
}

// --- Matcap texture from File object ---
function loadMatcapTextureFromFile(fileObj) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const loader = new THREE.TextureLoader();
      loader.load(e.target.result, (tex) => {
        tex.colorSpace = THREE.SRGBColorSpace;
        const name = fileObj.name;
        state.matcapTextures[name] = tex;
        resolve({ texture: tex, name });
      });
    };
    reader.readAsDataURL(fileObj);
  });
}

// --- Drop indicator ---
function showMatcapDropIndicator() {
  const el = document.getElementById('matcap-drop-indicator');
  const rect = dom.container.getBoundingClientRect();
  el.style.left = rect.left + 'px';
  el.style.top = rect.top + 'px';
  el.style.width = rect.width + 'px';
  el.style.height = rect.height + 'px';
  el.style.display = 'block';
}
function hideMatcapDropIndicator() {
  document.getElementById('matcap-drop-indicator').style.display = 'none';
}

// --- Raycast to find material under mouse ---
function raycastMaterialAt(clientX, clientY) {
  if (!state.currentModel) return null;

  const rect = state.renderer.domElement.getBoundingClientRect();
  const mouse = new THREE.Vector2(
    ((clientX - rect.left) / rect.width) * 2 - 1,
    -((clientY - rect.top) / rect.height) * 2 + 1
  );

  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(mouse, state.camera);

  const meshes = [];
  state.currentModel.traverse((o) => { if (o.isMesh) meshes.push(o); });

  const hits = raycaster.intersectObjects(meshes, false);
  if (hits.length === 0) return null;

  const hit = hits[0];
  const mesh = hit.object;
  let mat;
  if (Array.isArray(mesh.material)) {
    // face.materialIndex ã§ç‰¹å®š
    const idx = hit.face?.materialIndex ?? 0;
    mat = mesh.material[idx];
  } else {
    mat = mesh.material;
  }

  if (mat && (!mat.name || !mat.name.trim())) {
    mat.name = `MaterialID_${mat.id}`;
  }

  return { mesh, material: mat, materialName: mat?.name || '' };
}

// --- Apply matcap to a material by name ---
async function applyMatcapToMaterial(materialName, matcapFile) {
  if (!state.currentModel || !materialName) return;

  const tex = await loadMatcapTexture(matcapFile);

  state.currentModel.traverse((child) => {
    if (!child.isMesh) return;
    const mats = Array.isArray(child.material) ? child.material : [child.material];
    const newMats = mats.map((m, idx) => {
      if (!m || m.name !== materialName) return m;

      // å…ƒãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä¿å­˜ï¼ˆåˆå›ã®ã¿ï¼‰
      if (!state.matcapOriginals[materialName]) {
        state.matcapOriginals[materialName] = m;
      }
      const base = state.matcapOriginals[materialName] || m;

      const matcapMat = new THREE.MeshMatcapMaterial({
        matcap: tex,
        color: 0xffffff, // ãƒ™ãƒ¼ã‚¹ã‚«ãƒ©ãƒ¼ã¯ç™½
        map: null, // å…ƒã®ãƒ†ã‚¯ã‚¹ãƒãƒ£(map)ã¯ç„¡è¦–
        transparent: !!base.transparent,
        opacity: base.opacity ?? 1.0,
        side: base.side ?? THREE.FrontSide,
        alphaTest: base.alphaTest ?? 0,
      });
      matcapMat.name = materialName;
      // Matcapã¯éœ²å‡ºï¼ˆtoneMappingExposureï¼‰ã®å½±éŸ¿ã‚’å—ã‘ãªã„
      matcapMat.toneMapped = false;
      return matcapMat;
    });

    if (Array.isArray(child.material)) {
      child.material = newMats;
    } else {
      child.material = newMats[0];
    }
  });

  state.matcapAssignments[materialName] = matcapFile;
  renderMatcapAssignments();
  schedulePresetAutoSave();
  console.log(`[Matcap] Applied "${matcapFile}" to material "${materialName}"`);
}

// --- Remove matcap from a material ---
function removeMatcapFromMaterial(materialName) {
  if (!state.currentModel) return;

  const original = state.matcapOriginals[materialName];
  if (original && original.color && original.color.isColor) original.color.set(0xffffff);
  if (!original) return;

  state.currentModel.traverse((child) => {
    if (!child.isMesh) return;
    const mats = Array.isArray(child.material) ? child.material : [child.material];
    const newMats = mats.map((m) => {
      if (!m || m.name !== materialName) return m;
      return original;
    });
    if (Array.isArray(child.material)) {
      child.material = newMats;
    } else {
      child.material = newMats[0];
    }
  });

  delete state.matcapAssignments[materialName];
  delete state.matcapOriginals[materialName];
  renderMatcapAssignments();
  schedulePresetAutoSave();
  console.log(`[Matcap] Removed matcap from material "${materialName}"`);
}

// --- Remove all matcaps ---
function removeAllMatcaps() {
  const names = Object.keys(state.matcapAssignments);
  for (const name of names) {
    removeMatcapFromMaterial(name);
  }
}

// --- Remove all metalness ---
function removeAllMetalness() {
  const names = Object.keys(state.metalnessAssignments);
  for (const name of names) {
    removeMetalnessFromMaterial(name);
  }
}

// --- Apply metalness to a material by name ---
function applyMetalnessToMaterial(materialName, metalness) {
  if (!state.currentModel || !materialName) return;

  // Matcapé©ç”¨ä¸­ã¯ã€ç¾åœ¨ã®ãƒãƒ†ãƒªã‚¢ãƒ«ãŒ MeshMatcapMaterial ã«ãªã£ã¦ãŠã‚Š clearcoat ã‚’è¨­å®šã§ããªã„ã€‚
  // ã¾ãš Matcap ã‚’è§£é™¤ã—ã¦ã‹ã‚‰åå°„ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’é©ç”¨ã—ã¦ãã ã•ã„ã€‚
  if (state.matcapAssignments && state.matcapAssignments[materialName]) {
    notify('Matcapé©ç”¨ä¸­ã®ãƒãƒ†ãƒªã‚¢ãƒ«ã«ã¯åå°„ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’é©ç”¨ã§ãã¾ã›ã‚“ï¼ˆå…ˆã«Matcapã‚’è§£é™¤ã—ã¦ãã ã•ã„ï¼‰');
    return;
  }

  const EPS = 1e-6;

  // åå°„ãƒ—ãƒªã‚»ãƒƒãƒˆï¼ˆæ—§: metalness 0/0.5/1ï¼‰ã‚’ clearcoat ã«èª­ã¿æ›¿ãˆã‚‹
  let clearcoat = 0.0;
  let clearcoatRoughness = 0.5;

  if (Math.abs(metalness - 1.0) < EPS) {
    // åå°„100
    clearcoat = 1.0;
    clearcoatRoughness = 0.03;
  } else if (Math.abs(metalness - 0.5) < EPS) {
    // åå°„50
    clearcoat = 1.0;
    clearcoatRoughness = 0.25;
  } else if (Math.abs(metalness - 0.0) < EPS) {
    // åå°„0
    clearcoat = 0.0;
    clearcoatRoughness = 0.5;
  } else {
    // æƒ³å®šå¤–ã®å€¤ï¼ˆäº’æ›ç”¨ï¼‰
    clearcoat = metalness > 0 ? 1.0 : 0.0;
    clearcoatRoughness = metalness >= 0.75 ? 0.03 : 0.25;
  }

  // Standard â†’ Physical ã¸å¤‰æ›ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã®å†åˆ©ç”¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆåŒä¸€Materialã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¯¾ã—ã¦1å›ã ã‘ç”Ÿæˆï¼‰
  const stdToPhysical = new Map();

  state.currentModel.traverse((child) => {
    if (!child.isMesh) return;

    const isArray = Array.isArray(child.material);
    const mats = isArray ? child.material : [child.material];

    let changed = false;
    const newMats = mats.map((m) => {
      if (!m || m.name !== materialName) return m;
      if (!m.isMeshStandardMaterial && !m.isMeshPhysicalMaterial) return m;

      // --- å…ƒã®å€¤ã‚’ä¿å­˜ï¼ˆåˆå›ã®ã¿ï¼‰ ---
      if (state.clearcoatOriginals[materialName] === undefined) {
        state.clearcoatOriginals[materialName] = (typeof m.clearcoat === 'number') ? m.clearcoat : 0.0;
      }
      if (state.clearcoatRoughnessOriginals[materialName] === undefined) {
        state.clearcoatRoughnessOriginals[materialName] = (typeof m.clearcoatRoughness === 'number') ? m.clearcoatRoughness : 0.0;
      }
      if (state.toneMappedOriginals[materialName] === undefined) {
        state.toneMappedOriginals[materialName] = (m.toneMapped !== undefined) ? m.toneMapped : true;
      }

      // --- MeshStandardMaterial ã®å ´åˆã¯ MeshPhysicalMaterial ã«ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ ---
      let target = m;

      if (!m.isMeshPhysicalMaterial) {
        const cached = stdToPhysical.get(m.uuid);
        if (cached) {
          target = cached;
        } else {
          const phys = new THREE.MeshPhysicalMaterial();
          phys.copy(m);
          phys.name = m.name;
          phys.userData = m.userData;
          stdToPhysical.set(m.uuid, phys);
          target = phys;
        }

        // è§£é™¤ç”¨ã«ã€Œå…ƒã®ãƒãƒ†ãƒªã‚¢ãƒ«ã€ã‚’ä¿å­˜ï¼ˆåˆå›ã®ã¿ï¼‰
        if (state.clearcoatOriginalMaterials[materialName] === undefined) {
          state.clearcoatOriginalMaterials[materialName] = m;
        }

        changed = true;
      }

      // --- åå°„ï¼ˆclearcoatï¼‰ ---
      target.clearcoat = clearcoat;
      target.clearcoatRoughness = clearcoatRoughness;

      // éœ²å‡ºï¼ˆtoneMappingExposureï¼‰ã®å½±éŸ¿ã‚’å—ã‘ã‚‹ï¼ˆé€šå¸¸ã®ãƒˆãƒ¼ãƒ³ãƒãƒƒãƒ”ãƒ³ã‚°ã«å¾“ã†ï¼‰
      if (state.toneMappedOriginals[materialName] !== undefined) {
        target.toneMapped = state.toneMappedOriginals[materialName];
      }

      // clearcoat ã®æœ‰ç„¡ã§ã‚·ã‚§ãƒ¼ãƒ€å®šç¾©ãŒå¤‰ã‚ã‚‹ãŸã‚ needsUpdate
      target.needsUpdate = true;

      return target;
    });

    if (changed) {
      if (isArray) child.material = newMats;
      else child.material = newMats[0];
    }
  });

  state.metalnessAssignments[materialName] = metalness;
  renderAllAssignments();
  schedulePresetAutoSave();

  updateEnvIntensity();

  console.log(`[Reflect] Set "${materialName}" clearcoat=${clearcoat}, clearcoatRoughness=${clearcoatRoughness} (preset=${metalness})`);
}


 // --- Remove metalness from a material (restore original) ---

function removeMetalnessFromMaterial(materialName) {
  if (!state.currentModel) return;

  const origClearcoat = state.clearcoatOriginals[materialName];
  const origClearcoatRough = state.clearcoatRoughnessOriginals[materialName];
  const origToneMapped = state.toneMappedOriginals[materialName];

  // Standardâ†’Physical ã«ç½®ãæ›ãˆãŸå ´åˆã¯ã€å…ƒã®ãƒãƒ†ãƒªã‚¢ãƒ«ã¸æˆ»ã™
  const originalMat = state.clearcoatOriginalMaterials[materialName];

  state.currentModel.traverse((child) => {
    if (!child.isMesh) return;

    const isArray = Array.isArray(child.material);
    const mats = isArray ? child.material : [child.material];

    const newMats = mats.map((m) => {
      if (!m || m.name !== materialName) return m;

      if (originalMat) {
        return originalMat;
      }

      // ç‰©ç†ãƒãƒ†ãƒªã‚¢ãƒ«ã®å ´åˆã¯å€¤ã‚’æˆ»ã™
      if (m.isMeshPhysicalMaterial) {
        if (origClearcoat !== undefined) m.clearcoat = origClearcoat;
        if (origClearcoatRough !== undefined) m.clearcoatRoughness = origClearcoatRough;
        if (origToneMapped !== undefined) m.toneMapped = origToneMapped;
        m.needsUpdate = true;
      } else if (m.isMeshStandardMaterial) {
        if (origToneMapped !== undefined) m.toneMapped = origToneMapped;
      }
      return m;
    });

    if (isArray) child.material = newMats;
    else child.material = newMats[0];
  });

  delete state.metalnessAssignments[materialName];

  // ã‚¯ãƒªã‚¢ã‚³ãƒ¼ãƒˆé–¢é€£ã®ä¿å­˜å€¤ã‚’ç ´æ£„
  delete state.clearcoatOriginals[materialName];
  delete state.clearcoatRoughnessOriginals[materialName];
  delete state.toneMappedOriginals[materialName];
  delete state.clearcoatOriginalMaterials[materialName];

  // æ—§ä»•æ§˜ã®ä¿å­˜å€¤ã‚‚å¿µã®ãŸã‚ç ´æ£„ï¼ˆäº’æ›ï¼‰
  delete state.metalnessOriginals[materialName];
  delete state.roughnessOriginals[materialName];

  renderAllAssignments();
  schedulePresetAutoSave();
  updateEnvIntensity();
}


 // --- Render assignment list (matcap + metalness) ---

function renderAllAssignments() {
  const container = document.getElementById('matcap-assignments');
  const matcapEntries = Object.entries(state.matcapAssignments);
  const metalnessEntries = Object.entries(state.metalnessAssignments);

  if (matcapEntries.length === 0 && metalnessEntries.length === 0) {
    container.innerHTML = '<div class="hint">ãªã—</div>';
    return;
  }

  container.innerHTML = '';

  // Metalness assignments
  for (const [matName, metalness] of metalnessEntries) {
    const row = document.createElement('div');
    row.className = 'matcap-assign-item';
    row.innerHTML = `
      <div class="matcap-assign-info">
        <span style="display:inline-block;width:24px;height:24px;border-radius:3px;background:linear-gradient(135deg,#444,#aaa);font-size:9px;line-height:24px;text-align:center;font-weight:700;color:#222;">${(metalness * 100).toFixed(0)}</span>
        <span class="matcap-mat-name" title="${matName}">${matName}</span>
        <span style="font-size:10px;color:var(--text-dim);margin-left:4px">åå°„${(metalness * 100).toFixed(0)}</span>
      </div>
      <button title="è§£é™¤">âœ•</button>
    `;
    row.querySelector('button').addEventListener('click', () => {
      removeMetalnessFromMaterial(matName);
    });
    container.appendChild(row);
  }

  // Matcap assignments
  for (const [matName, file] of matcapEntries) {
    const row = document.createElement('div');
    row.className = 'matcap-assign-item';
    row.innerHTML = `
      <div class="matcap-assign-info">
        <img src="${encodeURI(MATCAP_DIR + file)}" alt="">
        <span class="matcap-mat-name" title="${matName}">${matName}</span>
      </div>
      <button title="è§£é™¤">âœ•</button>
    `;
    row.querySelector('button').addEventListener('click', () => {
      removeMatcapFromMaterial(matName);
    });
    container.appendChild(row);
  }
}

// å¾Œæ–¹äº’æ›
function renderMatcapAssignments() { renderAllAssignments(); }

// --- Re-apply matcap assignments after model reload ---
async function reapplyMatcapAssignments(assignments) {
  if (!assignments || typeof assignments !== 'object') return;

  // ç¾ãƒ¢ãƒ‡ãƒ«ã®ãƒãƒ†ãƒªã‚¢ãƒ«åä¸€è¦§ã‚’åé›†
  const modelMatNames = new Set();
  if (state.currentModel) {
    state.currentModel.traverse((o) => {
      if (!o.isMesh) return;
      const mats = Array.isArray(o.material) ? o.material : [o.material];
      mats.forEach((m) => { if (m?.name) modelMatNames.add(m.name); });
    });
  }

  let applied = 0;
  let skipped = 0;
  for (const [matName, file] of Object.entries(assignments)) {
    // ãƒãƒ†ãƒªã‚¢ãƒ«åãŒãƒ¢ãƒ‡ãƒ«ã«å­˜åœ¨ã—ã€matcapãƒ•ã‚¡ã‚¤ãƒ«ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã®ã¿é©ç”¨
    if (!modelMatNames.has(matName)) { skipped++; continue; }
    if (!state.matcapFiles.includes(file) && !state.matcapTextures[file]) { skipped++; continue; }
    try {
      await applyMatcapToMaterial(matName, file);
      applied++;
    } catch (e) {
      console.warn(`[Matcap] Failed to re-apply "${file}" to "${matName}":`, e);
      skipped++;
    }
  }
  if (applied > 0) console.log(`[Matcap] Re-applied ${applied} matcap(s), skipped ${skipped}`);
}

// --- Get matcap/metalness data for preset save ---
function getMatcapData() {
  return { ...state.matcapAssignments };
}
function getMetalnessData() {
  return { ...state.metalnessAssignments };
}

// --- Viewport drop handling ---
function initMatcapDragDrop() {
  const canvas = dom.container;

  canvas.addEventListener('dragover', (e) => {
    if (e.dataTransfer.types.includes('text/matcap-file') || e.dataTransfer.types.includes('text/metalness-preset')) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
      showMatcapDropIndicator();
    }
  });

  canvas.addEventListener('dragleave', (e) => {
    // Only hide if actually leaving the container
    if (!canvas.contains(e.relatedTarget)) {
      hideMatcapDropIndicator();
    }
  });

  canvas.addEventListener('drop', async (e) => {
    hideMatcapDropIndicator();

    // --- Metalness preset ---
    const metalnessData = e.dataTransfer.getData('text/metalness-preset');
    if (metalnessData !== '') {
      e.preventDefault();
      const metalness = parseFloat(metalnessData);
      const hit = raycastMaterialAt(e.clientX, e.clientY);
      if (!hit || !hit.materialName) {
        notify('ãƒãƒ†ãƒªã‚¢ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆãƒ¢ãƒ‡ãƒ«ã®ä¸Šã«ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦ãã ã•ã„ï¼‰');
        return;
      }
      applyMetalnessToMaterial(hit.materialName, metalness);
      notify(`"${hit.materialName}" ã®åå°„ã‚’ ${(metalness * 100).toFixed(0)} ã«è¨­å®šã—ã¾ã—ãŸ`);
      return;
    }

    // --- Matcap ---
    const matcapFile = e.dataTransfer.getData('text/matcap-file');
    if (!matcapFile) return;

    e.preventDefault();

    const hit = raycastMaterialAt(e.clientX, e.clientY);
    if (!hit || !hit.materialName) {
      notify('ãƒãƒ†ãƒªã‚¢ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆãƒ¢ãƒ‡ãƒ«ã®ä¸Šã«ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦ãã ã•ã„ï¼‰');
      return;
    }

    notify(`"${hit.materialName}" ã«ãƒãƒƒãƒˆã‚­ãƒ£ãƒƒãƒ—ã‚’é©ç”¨ä¸­...`);
    await applyMatcapToMaterial(hit.materialName, matcapFile);
    notify(`"${hit.materialName}" ã« "${matcapFile}" ã‚’é©ç”¨ã—ã¾ã—ãŸ`);
  });

  // File input for adding new matcaps
  document.getElementById('matcap-file-input').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    e.target.value = '';

    const { texture, name } = await loadMatcapTextureFromFile(file);

    // Add to file list and re-render gallery
    if (!state.matcapFiles.includes(name)) {
      state.matcapFiles.push(name);
    }

    // For file-uploaded matcaps, create a data URL thumbnail
    const thumbUrl = URL.createObjectURL(file);
    const gallery = document.getElementById('matcap-gallery');

    // Remove "no files" hint if present
    const hint = gallery.querySelector('.hint');
    if (hint) hint.remove();

    const img = document.createElement('img');
    img.className = 'matcap-thumb';
    img.src = thumbUrl;
    img.alt = name;
    img.title = name;
    img.draggable = true;
    img.dataset.matcapFile = name;

    img.addEventListener('dragstart', (ev) => {
      ev.dataTransfer.setData('text/matcap-file', name);
      img.classList.add('dragging');
    });
    img.addEventListener('dragend', () => {
      img.classList.remove('dragging');
      hideMatcapDropIndicator();
    });

    gallery.appendChild(img);
    notify(`ãƒãƒƒãƒˆã‚­ãƒ£ãƒƒãƒ— "${name}" ã‚’è¿½åŠ ã—ã¾ã—ãŸ`);
  });

  // Clear all button
  document.getElementById('btn-clear-all-matcap').addEventListener('click', () => {
    removeAllMatcaps();
    removeAllMetalness();
    notify('ã™ã¹ã¦ã®ãƒãƒ†ãƒªã‚¢ãƒ«è¨­å®šã‚’è§£é™¤ã—ã¾ã—ãŸ');
  });
}

// ===== Init =====
function init() {
  // ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹åˆ¤å®š
  if (IS_TOUCH) {
    document.body.classList.add('is-touch');
    // ã‚¯ãƒ­ã‚¹ãƒ˜ã‚¢éè¡¨ç¤º
    const crosshair = document.getElementById('crosshair');
    if (crosshair) crosshair.style.display = 'none';
  }

  initThree();
  initFileInputs();
  initMatcapDragDrop();
  loadMatcapList();
  autoLoadPresets();
  autoLoadGLTF();

  // ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«åˆæœŸåŒ–
  initJoystick();
  initTouchLook();
  initTouchVerticalBtns();

  animate();
}

init();
</script>

</body>
</html>
